// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mifare/av2/change_keyentry.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mifare_2fav2_2fchange_5fkeyentry_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mifare_2fav2_2fchange_5fkeyentry_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "contact/card_slot.pb.h"
#include "mifare/av2/channel.pb.h"
#include "mifare/av2/key_position.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mifare_2fav2_2fchange_5fkeyentry_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mifare_2fav2_2fchange_5fkeyentry_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mifare_2fav2_2fchange_5fkeyentry_2eproto;
namespace mifare {
namespace av2 {
namespace change_keyentry {
class ChangeKeyEntry;
class ChangeKeyEntryDefaultTypeInternal;
extern ChangeKeyEntryDefaultTypeInternal _ChangeKeyEntry_default_instance_;
class MifareKey;
class MifareKeyDefaultTypeInternal;
extern MifareKeyDefaultTypeInternal _MifareKey_default_instance_;
class MifareKeyEntry;
class MifareKeyEntryDefaultTypeInternal;
extern MifareKeyEntryDefaultTypeInternal _MifareKeyEntry_default_instance_;
class MifareKey_DiversificationKey;
class MifareKey_DiversificationKeyDefaultTypeInternal;
extern MifareKey_DiversificationKeyDefaultTypeInternal _MifareKey_DiversificationKey_default_instance_;
class PlusKeyEntry;
class PlusKeyEntryDefaultTypeInternal;
extern PlusKeyEntryDefaultTypeInternal _PlusKeyEntry_default_instance_;
class UltralightCKeyEntry;
class UltralightCKeyEntryDefaultTypeInternal;
extern UltralightCKeyEntryDefaultTypeInternal _UltralightCKeyEntry_default_instance_;
}  // namespace change_keyentry
}  // namespace av2
}  // namespace mifare
PROTOBUF_NAMESPACE_OPEN
template<> ::mifare::av2::change_keyentry::ChangeKeyEntry* Arena::CreateMaybeMessage<::mifare::av2::change_keyentry::ChangeKeyEntry>(Arena*);
template<> ::mifare::av2::change_keyentry::MifareKey* Arena::CreateMaybeMessage<::mifare::av2::change_keyentry::MifareKey>(Arena*);
template<> ::mifare::av2::change_keyentry::MifareKeyEntry* Arena::CreateMaybeMessage<::mifare::av2::change_keyentry::MifareKeyEntry>(Arena*);
template<> ::mifare::av2::change_keyentry::MifareKey_DiversificationKey* Arena::CreateMaybeMessage<::mifare::av2::change_keyentry::MifareKey_DiversificationKey>(Arena*);
template<> ::mifare::av2::change_keyentry::PlusKeyEntry* Arena::CreateMaybeMessage<::mifare::av2::change_keyentry::PlusKeyEntry>(Arena*);
template<> ::mifare::av2::change_keyentry::UltralightCKeyEntry* Arena::CreateMaybeMessage<::mifare::av2::change_keyentry::UltralightCKeyEntry>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mifare {
namespace av2 {
namespace change_keyentry {

// ===================================================================

class ChangeKeyEntry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mifare.av2.change_keyentry.ChangeKeyEntry) */ {
 public:
  ChangeKeyEntry();
  virtual ~ChangeKeyEntry();

  ChangeKeyEntry(const ChangeKeyEntry& from);
  ChangeKeyEntry(ChangeKeyEntry&& from) noexcept
    : ChangeKeyEntry() {
    *this = ::std::move(from);
  }

  inline ChangeKeyEntry& operator=(const ChangeKeyEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeKeyEntry& operator=(ChangeKeyEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChangeKeyEntry& default_instance();

  enum KeyEntryCase {
    kMifare = 6,
    kPlus = 7,
    kUltralightC = 8,
    KEY_ENTRY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeKeyEntry* internal_default_instance() {
    return reinterpret_cast<const ChangeKeyEntry*>(
               &_ChangeKeyEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ChangeKeyEntry& a, ChangeKeyEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeKeyEntry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChangeKeyEntry* New() const final {
    return CreateMaybeMessage<ChangeKeyEntry>(nullptr);
  }

  ChangeKeyEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangeKeyEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChangeKeyEntry& from);
  void MergeFrom(const ChangeKeyEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeKeyEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mifare.av2.change_keyentry.ChangeKeyEntry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mifare_2fav2_2fchange_5fkeyentry_2eproto);
    return ::descriptor_table_mifare_2fav2_2fchange_5fkeyentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotFieldNumber = 1,
    kChannelFieldNumber = 2,
    kKeyentryNumberFieldNumber = 3,
    kKeyVersionFieldNumber = 4,
    kKeyPositionFieldNumber = 5,
    kMifareFieldNumber = 6,
    kPlusFieldNumber = 7,
    kUltralightCFieldNumber = 8,
  };
  // required .contact.card_slot.CardSlot slot = 1;
  bool has_slot() const;
  private:
  bool _internal_has_slot() const;
  public:
  void clear_slot();
  ::contact::card_slot::CardSlot slot() const;
  void set_slot(::contact::card_slot::CardSlot value);
  private:
  ::contact::card_slot::CardSlot _internal_slot() const;
  void _internal_set_slot(::contact::card_slot::CardSlot value);
  public:

  // optional .mifare.av2.channel.Channel channel = 2 [default = AV2_CHANNEL_0];
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  ::mifare::av2::channel::Channel channel() const;
  void set_channel(::mifare::av2::channel::Channel value);
  private:
  ::mifare::av2::channel::Channel _internal_channel() const;
  void _internal_set_channel(::mifare::av2::channel::Channel value);
  public:

  // required uint32 keyentry_number = 3;
  bool has_keyentry_number() const;
  private:
  bool _internal_has_keyentry_number() const;
  public:
  void clear_keyentry_number();
  ::PROTOBUF_NAMESPACE_ID::uint32 keyentry_number() const;
  void set_keyentry_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_keyentry_number() const;
  void _internal_set_keyentry_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 key_version = 4;
  bool has_key_version() const;
  private:
  bool _internal_has_key_version() const;
  public:
  void clear_key_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 key_version() const;
  void set_key_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_key_version() const;
  void _internal_set_key_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .mifare.av2.key_position.KeyPosition key_position = 5 [default = POSITION_A];
  bool has_key_position() const;
  private:
  bool _internal_has_key_position() const;
  public:
  void clear_key_position();
  ::mifare::av2::key_position::KeyPosition key_position() const;
  void set_key_position(::mifare::av2::key_position::KeyPosition value);
  private:
  ::mifare::av2::key_position::KeyPosition _internal_key_position() const;
  void _internal_set_key_position(::mifare::av2::key_position::KeyPosition value);
  public:

  // optional .mifare.av2.change_keyentry.MifareKeyEntry mifare = 6;
  bool has_mifare() const;
  private:
  bool _internal_has_mifare() const;
  public:
  void clear_mifare();
  const ::mifare::av2::change_keyentry::MifareKeyEntry& mifare() const;
  ::mifare::av2::change_keyentry::MifareKeyEntry* release_mifare();
  ::mifare::av2::change_keyentry::MifareKeyEntry* mutable_mifare();
  void set_allocated_mifare(::mifare::av2::change_keyentry::MifareKeyEntry* mifare);
  private:
  const ::mifare::av2::change_keyentry::MifareKeyEntry& _internal_mifare() const;
  ::mifare::av2::change_keyentry::MifareKeyEntry* _internal_mutable_mifare();
  public:

  // optional .mifare.av2.change_keyentry.PlusKeyEntry plus = 7;
  bool has_plus() const;
  private:
  bool _internal_has_plus() const;
  public:
  void clear_plus();
  const ::mifare::av2::change_keyentry::PlusKeyEntry& plus() const;
  ::mifare::av2::change_keyentry::PlusKeyEntry* release_plus();
  ::mifare::av2::change_keyentry::PlusKeyEntry* mutable_plus();
  void set_allocated_plus(::mifare::av2::change_keyentry::PlusKeyEntry* plus);
  private:
  const ::mifare::av2::change_keyentry::PlusKeyEntry& _internal_plus() const;
  ::mifare::av2::change_keyentry::PlusKeyEntry* _internal_mutable_plus();
  public:

  // optional .mifare.av2.change_keyentry.UltralightCKeyEntry ultralight_c = 8;
  bool has_ultralight_c() const;
  private:
  bool _internal_has_ultralight_c() const;
  public:
  void clear_ultralight_c();
  const ::mifare::av2::change_keyentry::UltralightCKeyEntry& ultralight_c() const;
  ::mifare::av2::change_keyentry::UltralightCKeyEntry* release_ultralight_c();
  ::mifare::av2::change_keyentry::UltralightCKeyEntry* mutable_ultralight_c();
  void set_allocated_ultralight_c(::mifare::av2::change_keyentry::UltralightCKeyEntry* ultralight_c);
  private:
  const ::mifare::av2::change_keyentry::UltralightCKeyEntry& _internal_ultralight_c() const;
  ::mifare::av2::change_keyentry::UltralightCKeyEntry* _internal_mutable_ultralight_c();
  public:

  void clear_key_entry();
  KeyEntryCase key_entry_case() const;
  // @@protoc_insertion_point(class_scope:mifare.av2.change_keyentry.ChangeKeyEntry)
 private:
  class _Internal;
  void set_has_mifare();
  void set_has_plus();
  void set_has_ultralight_c();

  inline bool has_key_entry() const;
  inline void clear_has_key_entry();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int slot_;
  int channel_;
  ::PROTOBUF_NAMESPACE_ID::uint32 keyentry_number_;
  ::PROTOBUF_NAMESPACE_ID::uint32 key_version_;
  int key_position_;
  union KeyEntryUnion {
    KeyEntryUnion() {}
    ::mifare::av2::change_keyentry::MifareKeyEntry* mifare_;
    ::mifare::av2::change_keyentry::PlusKeyEntry* plus_;
    ::mifare::av2::change_keyentry::UltralightCKeyEntry* ultralight_c_;
  } key_entry_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_mifare_2fav2_2fchange_5fkeyentry_2eproto;
};
// -------------------------------------------------------------------

class MifareKeyEntry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mifare.av2.change_keyentry.MifareKeyEntry) */ {
 public:
  MifareKeyEntry();
  virtual ~MifareKeyEntry();

  MifareKeyEntry(const MifareKeyEntry& from);
  MifareKeyEntry(MifareKeyEntry&& from) noexcept
    : MifareKeyEntry() {
    *this = ::std::move(from);
  }

  inline MifareKeyEntry& operator=(const MifareKeyEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline MifareKeyEntry& operator=(MifareKeyEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MifareKeyEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MifareKeyEntry* internal_default_instance() {
    return reinterpret_cast<const MifareKeyEntry*>(
               &_MifareKeyEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MifareKeyEntry& a, MifareKeyEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(MifareKeyEntry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MifareKeyEntry* New() const final {
    return CreateMaybeMessage<MifareKeyEntry>(nullptr);
  }

  MifareKeyEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MifareKeyEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MifareKeyEntry& from);
  void MergeFrom(const MifareKeyEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MifareKeyEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mifare.av2.change_keyentry.MifareKeyEntry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mifare_2fav2_2fchange_5fkeyentry_2eproto);
    return ::descriptor_table_mifare_2fav2_2fchange_5fkeyentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyAFieldNumber = 1,
    kKeyBFieldNumber = 2,
  };
  // required .mifare.av2.change_keyentry.MifareKey key_a = 1;
  bool has_key_a() const;
  private:
  bool _internal_has_key_a() const;
  public:
  void clear_key_a();
  const ::mifare::av2::change_keyentry::MifareKey& key_a() const;
  ::mifare::av2::change_keyentry::MifareKey* release_key_a();
  ::mifare::av2::change_keyentry::MifareKey* mutable_key_a();
  void set_allocated_key_a(::mifare::av2::change_keyentry::MifareKey* key_a);
  private:
  const ::mifare::av2::change_keyentry::MifareKey& _internal_key_a() const;
  ::mifare::av2::change_keyentry::MifareKey* _internal_mutable_key_a();
  public:

  // required .mifare.av2.change_keyentry.MifareKey key_b = 2;
  bool has_key_b() const;
  private:
  bool _internal_has_key_b() const;
  public:
  void clear_key_b();
  const ::mifare::av2::change_keyentry::MifareKey& key_b() const;
  ::mifare::av2::change_keyentry::MifareKey* release_key_b();
  ::mifare::av2::change_keyentry::MifareKey* mutable_key_b();
  void set_allocated_key_b(::mifare::av2::change_keyentry::MifareKey* key_b);
  private:
  const ::mifare::av2::change_keyentry::MifareKey& _internal_key_b() const;
  ::mifare::av2::change_keyentry::MifareKey* _internal_mutable_key_b();
  public:

  // @@protoc_insertion_point(class_scope:mifare.av2.change_keyentry.MifareKeyEntry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::mifare::av2::change_keyentry::MifareKey* key_a_;
  ::mifare::av2::change_keyentry::MifareKey* key_b_;
  friend struct ::TableStruct_mifare_2fav2_2fchange_5fkeyentry_2eproto;
};
// -------------------------------------------------------------------

class MifareKey_DiversificationKey :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mifare.av2.change_keyentry.MifareKey.DiversificationKey) */ {
 public:
  MifareKey_DiversificationKey();
  virtual ~MifareKey_DiversificationKey();

  MifareKey_DiversificationKey(const MifareKey_DiversificationKey& from);
  MifareKey_DiversificationKey(MifareKey_DiversificationKey&& from) noexcept
    : MifareKey_DiversificationKey() {
    *this = ::std::move(from);
  }

  inline MifareKey_DiversificationKey& operator=(const MifareKey_DiversificationKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline MifareKey_DiversificationKey& operator=(MifareKey_DiversificationKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MifareKey_DiversificationKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MifareKey_DiversificationKey* internal_default_instance() {
    return reinterpret_cast<const MifareKey_DiversificationKey*>(
               &_MifareKey_DiversificationKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MifareKey_DiversificationKey& a, MifareKey_DiversificationKey& b) {
    a.Swap(&b);
  }
  inline void Swap(MifareKey_DiversificationKey* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MifareKey_DiversificationKey* New() const final {
    return CreateMaybeMessage<MifareKey_DiversificationKey>(nullptr);
  }

  MifareKey_DiversificationKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MifareKey_DiversificationKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MifareKey_DiversificationKey& from);
  void MergeFrom(const MifareKey_DiversificationKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MifareKey_DiversificationKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mifare.av2.change_keyentry.MifareKey.DiversificationKey";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mifare_2fav2_2fchange_5fkeyentry_2eproto);
    return ::descriptor_table_mifare_2fav2_2fchange_5fkeyentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // required uint32 number = 1;
  bool has_number() const;
  private:
  bool _internal_has_number() const;
  public:
  void clear_number();
  ::PROTOBUF_NAMESPACE_ID::uint32 number() const;
  void set_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_number() const;
  void _internal_set_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mifare.av2.change_keyentry.MifareKey.DiversificationKey)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 number_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  friend struct ::TableStruct_mifare_2fav2_2fchange_5fkeyentry_2eproto;
};
// -------------------------------------------------------------------

class MifareKey :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mifare.av2.change_keyentry.MifareKey) */ {
 public:
  MifareKey();
  virtual ~MifareKey();

  MifareKey(const MifareKey& from);
  MifareKey(MifareKey&& from) noexcept
    : MifareKey() {
    *this = ::std::move(from);
  }

  inline MifareKey& operator=(const MifareKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline MifareKey& operator=(MifareKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MifareKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MifareKey* internal_default_instance() {
    return reinterpret_cast<const MifareKey*>(
               &_MifareKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MifareKey& a, MifareKey& b) {
    a.Swap(&b);
  }
  inline void Swap(MifareKey* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MifareKey* New() const final {
    return CreateMaybeMessage<MifareKey>(nullptr);
  }

  MifareKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MifareKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MifareKey& from);
  void MergeFrom(const MifareKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MifareKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mifare.av2.change_keyentry.MifareKey";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mifare_2fav2_2fchange_5fkeyentry_2eproto);
    return ::descriptor_table_mifare_2fav2_2fchange_5fkeyentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MifareKey_DiversificationKey DiversificationKey;

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kDiversificationKeyFieldNumber = 2,
  };
  // required bytes key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional .mifare.av2.change_keyentry.MifareKey.DiversificationKey diversification_key = 2;
  bool has_diversification_key() const;
  private:
  bool _internal_has_diversification_key() const;
  public:
  void clear_diversification_key();
  const ::mifare::av2::change_keyentry::MifareKey_DiversificationKey& diversification_key() const;
  ::mifare::av2::change_keyentry::MifareKey_DiversificationKey* release_diversification_key();
  ::mifare::av2::change_keyentry::MifareKey_DiversificationKey* mutable_diversification_key();
  void set_allocated_diversification_key(::mifare::av2::change_keyentry::MifareKey_DiversificationKey* diversification_key);
  private:
  const ::mifare::av2::change_keyentry::MifareKey_DiversificationKey& _internal_diversification_key() const;
  ::mifare::av2::change_keyentry::MifareKey_DiversificationKey* _internal_mutable_diversification_key();
  public:

  // @@protoc_insertion_point(class_scope:mifare.av2.change_keyentry.MifareKey)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::mifare::av2::change_keyentry::MifareKey_DiversificationKey* diversification_key_;
  friend struct ::TableStruct_mifare_2fav2_2fchange_5fkeyentry_2eproto;
};
// -------------------------------------------------------------------

class PlusKeyEntry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mifare.av2.change_keyentry.PlusKeyEntry) */ {
 public:
  PlusKeyEntry();
  virtual ~PlusKeyEntry();

  PlusKeyEntry(const PlusKeyEntry& from);
  PlusKeyEntry(PlusKeyEntry&& from) noexcept
    : PlusKeyEntry() {
    *this = ::std::move(from);
  }

  inline PlusKeyEntry& operator=(const PlusKeyEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlusKeyEntry& operator=(PlusKeyEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlusKeyEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlusKeyEntry* internal_default_instance() {
    return reinterpret_cast<const PlusKeyEntry*>(
               &_PlusKeyEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PlusKeyEntry& a, PlusKeyEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(PlusKeyEntry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlusKeyEntry* New() const final {
    return CreateMaybeMessage<PlusKeyEntry>(nullptr);
  }

  PlusKeyEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlusKeyEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlusKeyEntry& from);
  void MergeFrom(const PlusKeyEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlusKeyEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mifare.av2.change_keyentry.PlusKeyEntry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mifare_2fav2_2fchange_5fkeyentry_2eproto);
    return ::descriptor_table_mifare_2fav2_2fchange_5fkeyentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // required bytes key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:mifare.av2.change_keyentry.PlusKeyEntry)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  friend struct ::TableStruct_mifare_2fav2_2fchange_5fkeyentry_2eproto;
};
// -------------------------------------------------------------------

class UltralightCKeyEntry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mifare.av2.change_keyentry.UltralightCKeyEntry) */ {
 public:
  UltralightCKeyEntry();
  virtual ~UltralightCKeyEntry();

  UltralightCKeyEntry(const UltralightCKeyEntry& from);
  UltralightCKeyEntry(UltralightCKeyEntry&& from) noexcept
    : UltralightCKeyEntry() {
    *this = ::std::move(from);
  }

  inline UltralightCKeyEntry& operator=(const UltralightCKeyEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline UltralightCKeyEntry& operator=(UltralightCKeyEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UltralightCKeyEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UltralightCKeyEntry* internal_default_instance() {
    return reinterpret_cast<const UltralightCKeyEntry*>(
               &_UltralightCKeyEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UltralightCKeyEntry& a, UltralightCKeyEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(UltralightCKeyEntry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UltralightCKeyEntry* New() const final {
    return CreateMaybeMessage<UltralightCKeyEntry>(nullptr);
  }

  UltralightCKeyEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UltralightCKeyEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UltralightCKeyEntry& from);
  void MergeFrom(const UltralightCKeyEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UltralightCKeyEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mifare.av2.change_keyentry.UltralightCKeyEntry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mifare_2fav2_2fchange_5fkeyentry_2eproto);
    return ::descriptor_table_mifare_2fav2_2fchange_5fkeyentry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // required bytes key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:mifare.av2.change_keyentry.UltralightCKeyEntry)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  friend struct ::TableStruct_mifare_2fav2_2fchange_5fkeyentry_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ChangeKeyEntry

// required .contact.card_slot.CardSlot slot = 1;
inline bool ChangeKeyEntry::_internal_has_slot() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangeKeyEntry::has_slot() const {
  return _internal_has_slot();
}
inline void ChangeKeyEntry::clear_slot() {
  slot_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::contact::card_slot::CardSlot ChangeKeyEntry::_internal_slot() const {
  return static_cast< ::contact::card_slot::CardSlot >(slot_);
}
inline ::contact::card_slot::CardSlot ChangeKeyEntry::slot() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.ChangeKeyEntry.slot)
  return _internal_slot();
}
inline void ChangeKeyEntry::_internal_set_slot(::contact::card_slot::CardSlot value) {
  assert(::contact::card_slot::CardSlot_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  slot_ = value;
}
inline void ChangeKeyEntry::set_slot(::contact::card_slot::CardSlot value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:mifare.av2.change_keyentry.ChangeKeyEntry.slot)
}

// optional .mifare.av2.channel.Channel channel = 2 [default = AV2_CHANNEL_0];
inline bool ChangeKeyEntry::_internal_has_channel() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeKeyEntry::has_channel() const {
  return _internal_has_channel();
}
inline void ChangeKeyEntry::clear_channel() {
  channel_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::mifare::av2::channel::Channel ChangeKeyEntry::_internal_channel() const {
  return static_cast< ::mifare::av2::channel::Channel >(channel_);
}
inline ::mifare::av2::channel::Channel ChangeKeyEntry::channel() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.ChangeKeyEntry.channel)
  return _internal_channel();
}
inline void ChangeKeyEntry::_internal_set_channel(::mifare::av2::channel::Channel value) {
  assert(::mifare::av2::channel::Channel_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  channel_ = value;
}
inline void ChangeKeyEntry::set_channel(::mifare::av2::channel::Channel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:mifare.av2.change_keyentry.ChangeKeyEntry.channel)
}

// required uint32 keyentry_number = 3;
inline bool ChangeKeyEntry::_internal_has_keyentry_number() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChangeKeyEntry::has_keyentry_number() const {
  return _internal_has_keyentry_number();
}
inline void ChangeKeyEntry::clear_keyentry_number() {
  keyentry_number_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChangeKeyEntry::_internal_keyentry_number() const {
  return keyentry_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChangeKeyEntry::keyentry_number() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.ChangeKeyEntry.keyentry_number)
  return _internal_keyentry_number();
}
inline void ChangeKeyEntry::_internal_set_keyentry_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  keyentry_number_ = value;
}
inline void ChangeKeyEntry::set_keyentry_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_keyentry_number(value);
  // @@protoc_insertion_point(field_set:mifare.av2.change_keyentry.ChangeKeyEntry.keyentry_number)
}

// required uint32 key_version = 4;
inline bool ChangeKeyEntry::_internal_has_key_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChangeKeyEntry::has_key_version() const {
  return _internal_has_key_version();
}
inline void ChangeKeyEntry::clear_key_version() {
  key_version_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChangeKeyEntry::_internal_key_version() const {
  return key_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChangeKeyEntry::key_version() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.ChangeKeyEntry.key_version)
  return _internal_key_version();
}
inline void ChangeKeyEntry::_internal_set_key_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  key_version_ = value;
}
inline void ChangeKeyEntry::set_key_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_key_version(value);
  // @@protoc_insertion_point(field_set:mifare.av2.change_keyentry.ChangeKeyEntry.key_version)
}

// optional .mifare.av2.key_position.KeyPosition key_position = 5 [default = POSITION_A];
inline bool ChangeKeyEntry::_internal_has_key_position() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ChangeKeyEntry::has_key_position() const {
  return _internal_has_key_position();
}
inline void ChangeKeyEntry::clear_key_position() {
  key_position_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::mifare::av2::key_position::KeyPosition ChangeKeyEntry::_internal_key_position() const {
  return static_cast< ::mifare::av2::key_position::KeyPosition >(key_position_);
}
inline ::mifare::av2::key_position::KeyPosition ChangeKeyEntry::key_position() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.ChangeKeyEntry.key_position)
  return _internal_key_position();
}
inline void ChangeKeyEntry::_internal_set_key_position(::mifare::av2::key_position::KeyPosition value) {
  assert(::mifare::av2::key_position::KeyPosition_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  key_position_ = value;
}
inline void ChangeKeyEntry::set_key_position(::mifare::av2::key_position::KeyPosition value) {
  _internal_set_key_position(value);
  // @@protoc_insertion_point(field_set:mifare.av2.change_keyentry.ChangeKeyEntry.key_position)
}

// optional .mifare.av2.change_keyentry.MifareKeyEntry mifare = 6;
inline bool ChangeKeyEntry::_internal_has_mifare() const {
  return key_entry_case() == kMifare;
}
inline bool ChangeKeyEntry::has_mifare() const {
  return _internal_has_mifare();
}
inline void ChangeKeyEntry::set_has_mifare() {
  _oneof_case_[0] = kMifare;
}
inline void ChangeKeyEntry::clear_mifare() {
  if (_internal_has_mifare()) {
    delete key_entry_.mifare_;
    clear_has_key_entry();
  }
}
inline ::mifare::av2::change_keyentry::MifareKeyEntry* ChangeKeyEntry::release_mifare() {
  // @@protoc_insertion_point(field_release:mifare.av2.change_keyentry.ChangeKeyEntry.mifare)
  if (_internal_has_mifare()) {
    clear_has_key_entry();
      ::mifare::av2::change_keyentry::MifareKeyEntry* temp = key_entry_.mifare_;
    key_entry_.mifare_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::av2::change_keyentry::MifareKeyEntry& ChangeKeyEntry::_internal_mifare() const {
  return _internal_has_mifare()
      ? *key_entry_.mifare_
      : *reinterpret_cast< ::mifare::av2::change_keyentry::MifareKeyEntry*>(&::mifare::av2::change_keyentry::_MifareKeyEntry_default_instance_);
}
inline const ::mifare::av2::change_keyentry::MifareKeyEntry& ChangeKeyEntry::mifare() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.ChangeKeyEntry.mifare)
  return _internal_mifare();
}
inline ::mifare::av2::change_keyentry::MifareKeyEntry* ChangeKeyEntry::_internal_mutable_mifare() {
  if (!_internal_has_mifare()) {
    clear_key_entry();
    set_has_mifare();
    key_entry_.mifare_ = CreateMaybeMessage< ::mifare::av2::change_keyentry::MifareKeyEntry >(
        GetArenaNoVirtual());
  }
  return key_entry_.mifare_;
}
inline ::mifare::av2::change_keyentry::MifareKeyEntry* ChangeKeyEntry::mutable_mifare() {
  // @@protoc_insertion_point(field_mutable:mifare.av2.change_keyentry.ChangeKeyEntry.mifare)
  return _internal_mutable_mifare();
}

// optional .mifare.av2.change_keyentry.PlusKeyEntry plus = 7;
inline bool ChangeKeyEntry::_internal_has_plus() const {
  return key_entry_case() == kPlus;
}
inline bool ChangeKeyEntry::has_plus() const {
  return _internal_has_plus();
}
inline void ChangeKeyEntry::set_has_plus() {
  _oneof_case_[0] = kPlus;
}
inline void ChangeKeyEntry::clear_plus() {
  if (_internal_has_plus()) {
    delete key_entry_.plus_;
    clear_has_key_entry();
  }
}
inline ::mifare::av2::change_keyentry::PlusKeyEntry* ChangeKeyEntry::release_plus() {
  // @@protoc_insertion_point(field_release:mifare.av2.change_keyentry.ChangeKeyEntry.plus)
  if (_internal_has_plus()) {
    clear_has_key_entry();
      ::mifare::av2::change_keyentry::PlusKeyEntry* temp = key_entry_.plus_;
    key_entry_.plus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::av2::change_keyentry::PlusKeyEntry& ChangeKeyEntry::_internal_plus() const {
  return _internal_has_plus()
      ? *key_entry_.plus_
      : *reinterpret_cast< ::mifare::av2::change_keyentry::PlusKeyEntry*>(&::mifare::av2::change_keyentry::_PlusKeyEntry_default_instance_);
}
inline const ::mifare::av2::change_keyentry::PlusKeyEntry& ChangeKeyEntry::plus() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.ChangeKeyEntry.plus)
  return _internal_plus();
}
inline ::mifare::av2::change_keyentry::PlusKeyEntry* ChangeKeyEntry::_internal_mutable_plus() {
  if (!_internal_has_plus()) {
    clear_key_entry();
    set_has_plus();
    key_entry_.plus_ = CreateMaybeMessage< ::mifare::av2::change_keyentry::PlusKeyEntry >(
        GetArenaNoVirtual());
  }
  return key_entry_.plus_;
}
inline ::mifare::av2::change_keyentry::PlusKeyEntry* ChangeKeyEntry::mutable_plus() {
  // @@protoc_insertion_point(field_mutable:mifare.av2.change_keyentry.ChangeKeyEntry.plus)
  return _internal_mutable_plus();
}

// optional .mifare.av2.change_keyentry.UltralightCKeyEntry ultralight_c = 8;
inline bool ChangeKeyEntry::_internal_has_ultralight_c() const {
  return key_entry_case() == kUltralightC;
}
inline bool ChangeKeyEntry::has_ultralight_c() const {
  return _internal_has_ultralight_c();
}
inline void ChangeKeyEntry::set_has_ultralight_c() {
  _oneof_case_[0] = kUltralightC;
}
inline void ChangeKeyEntry::clear_ultralight_c() {
  if (_internal_has_ultralight_c()) {
    delete key_entry_.ultralight_c_;
    clear_has_key_entry();
  }
}
inline ::mifare::av2::change_keyentry::UltralightCKeyEntry* ChangeKeyEntry::release_ultralight_c() {
  // @@protoc_insertion_point(field_release:mifare.av2.change_keyentry.ChangeKeyEntry.ultralight_c)
  if (_internal_has_ultralight_c()) {
    clear_has_key_entry();
      ::mifare::av2::change_keyentry::UltralightCKeyEntry* temp = key_entry_.ultralight_c_;
    key_entry_.ultralight_c_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::av2::change_keyentry::UltralightCKeyEntry& ChangeKeyEntry::_internal_ultralight_c() const {
  return _internal_has_ultralight_c()
      ? *key_entry_.ultralight_c_
      : *reinterpret_cast< ::mifare::av2::change_keyentry::UltralightCKeyEntry*>(&::mifare::av2::change_keyentry::_UltralightCKeyEntry_default_instance_);
}
inline const ::mifare::av2::change_keyentry::UltralightCKeyEntry& ChangeKeyEntry::ultralight_c() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.ChangeKeyEntry.ultralight_c)
  return _internal_ultralight_c();
}
inline ::mifare::av2::change_keyentry::UltralightCKeyEntry* ChangeKeyEntry::_internal_mutable_ultralight_c() {
  if (!_internal_has_ultralight_c()) {
    clear_key_entry();
    set_has_ultralight_c();
    key_entry_.ultralight_c_ = CreateMaybeMessage< ::mifare::av2::change_keyentry::UltralightCKeyEntry >(
        GetArenaNoVirtual());
  }
  return key_entry_.ultralight_c_;
}
inline ::mifare::av2::change_keyentry::UltralightCKeyEntry* ChangeKeyEntry::mutable_ultralight_c() {
  // @@protoc_insertion_point(field_mutable:mifare.av2.change_keyentry.ChangeKeyEntry.ultralight_c)
  return _internal_mutable_ultralight_c();
}

inline bool ChangeKeyEntry::has_key_entry() const {
  return key_entry_case() != KEY_ENTRY_NOT_SET;
}
inline void ChangeKeyEntry::clear_has_key_entry() {
  _oneof_case_[0] = KEY_ENTRY_NOT_SET;
}
inline ChangeKeyEntry::KeyEntryCase ChangeKeyEntry::key_entry_case() const {
  return ChangeKeyEntry::KeyEntryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MifareKeyEntry

// required .mifare.av2.change_keyentry.MifareKey key_a = 1;
inline bool MifareKeyEntry::_internal_has_key_a() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || key_a_ != nullptr);
  return value;
}
inline bool MifareKeyEntry::has_key_a() const {
  return _internal_has_key_a();
}
inline void MifareKeyEntry::clear_key_a() {
  if (key_a_ != nullptr) key_a_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mifare::av2::change_keyentry::MifareKey& MifareKeyEntry::_internal_key_a() const {
  const ::mifare::av2::change_keyentry::MifareKey* p = key_a_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mifare::av2::change_keyentry::MifareKey*>(
      &::mifare::av2::change_keyentry::_MifareKey_default_instance_);
}
inline const ::mifare::av2::change_keyentry::MifareKey& MifareKeyEntry::key_a() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.MifareKeyEntry.key_a)
  return _internal_key_a();
}
inline ::mifare::av2::change_keyentry::MifareKey* MifareKeyEntry::release_key_a() {
  // @@protoc_insertion_point(field_release:mifare.av2.change_keyentry.MifareKeyEntry.key_a)
  _has_bits_[0] &= ~0x00000001u;
  ::mifare::av2::change_keyentry::MifareKey* temp = key_a_;
  key_a_ = nullptr;
  return temp;
}
inline ::mifare::av2::change_keyentry::MifareKey* MifareKeyEntry::_internal_mutable_key_a() {
  _has_bits_[0] |= 0x00000001u;
  if (key_a_ == nullptr) {
    auto* p = CreateMaybeMessage<::mifare::av2::change_keyentry::MifareKey>(GetArenaNoVirtual());
    key_a_ = p;
  }
  return key_a_;
}
inline ::mifare::av2::change_keyentry::MifareKey* MifareKeyEntry::mutable_key_a() {
  // @@protoc_insertion_point(field_mutable:mifare.av2.change_keyentry.MifareKeyEntry.key_a)
  return _internal_mutable_key_a();
}
inline void MifareKeyEntry::set_allocated_key_a(::mifare::av2::change_keyentry::MifareKey* key_a) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete key_a_;
  }
  if (key_a) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      key_a = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_a, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_a_ = key_a;
  // @@protoc_insertion_point(field_set_allocated:mifare.av2.change_keyentry.MifareKeyEntry.key_a)
}

// required .mifare.av2.change_keyentry.MifareKey key_b = 2;
inline bool MifareKeyEntry::_internal_has_key_b() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || key_b_ != nullptr);
  return value;
}
inline bool MifareKeyEntry::has_key_b() const {
  return _internal_has_key_b();
}
inline void MifareKeyEntry::clear_key_b() {
  if (key_b_ != nullptr) key_b_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mifare::av2::change_keyentry::MifareKey& MifareKeyEntry::_internal_key_b() const {
  const ::mifare::av2::change_keyentry::MifareKey* p = key_b_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mifare::av2::change_keyentry::MifareKey*>(
      &::mifare::av2::change_keyentry::_MifareKey_default_instance_);
}
inline const ::mifare::av2::change_keyentry::MifareKey& MifareKeyEntry::key_b() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.MifareKeyEntry.key_b)
  return _internal_key_b();
}
inline ::mifare::av2::change_keyentry::MifareKey* MifareKeyEntry::release_key_b() {
  // @@protoc_insertion_point(field_release:mifare.av2.change_keyentry.MifareKeyEntry.key_b)
  _has_bits_[0] &= ~0x00000002u;
  ::mifare::av2::change_keyentry::MifareKey* temp = key_b_;
  key_b_ = nullptr;
  return temp;
}
inline ::mifare::av2::change_keyentry::MifareKey* MifareKeyEntry::_internal_mutable_key_b() {
  _has_bits_[0] |= 0x00000002u;
  if (key_b_ == nullptr) {
    auto* p = CreateMaybeMessage<::mifare::av2::change_keyentry::MifareKey>(GetArenaNoVirtual());
    key_b_ = p;
  }
  return key_b_;
}
inline ::mifare::av2::change_keyentry::MifareKey* MifareKeyEntry::mutable_key_b() {
  // @@protoc_insertion_point(field_mutable:mifare.av2.change_keyentry.MifareKeyEntry.key_b)
  return _internal_mutable_key_b();
}
inline void MifareKeyEntry::set_allocated_key_b(::mifare::av2::change_keyentry::MifareKey* key_b) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete key_b_;
  }
  if (key_b) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      key_b = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_b, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_b_ = key_b;
  // @@protoc_insertion_point(field_set_allocated:mifare.av2.change_keyentry.MifareKeyEntry.key_b)
}

// -------------------------------------------------------------------

// MifareKey_DiversificationKey

// required uint32 number = 1;
inline bool MifareKey_DiversificationKey::_internal_has_number() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MifareKey_DiversificationKey::has_number() const {
  return _internal_has_number();
}
inline void MifareKey_DiversificationKey::clear_number() {
  number_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MifareKey_DiversificationKey::_internal_number() const {
  return number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MifareKey_DiversificationKey::number() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.MifareKey.DiversificationKey.number)
  return _internal_number();
}
inline void MifareKey_DiversificationKey::_internal_set_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  number_ = value;
}
inline void MifareKey_DiversificationKey::set_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:mifare.av2.change_keyentry.MifareKey.DiversificationKey.number)
}

// required uint32 version = 2;
inline bool MifareKey_DiversificationKey::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MifareKey_DiversificationKey::has_version() const {
  return _internal_has_version();
}
inline void MifareKey_DiversificationKey::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MifareKey_DiversificationKey::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MifareKey_DiversificationKey::version() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.MifareKey.DiversificationKey.version)
  return _internal_version();
}
inline void MifareKey_DiversificationKey::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
}
inline void MifareKey_DiversificationKey::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:mifare.av2.change_keyentry.MifareKey.DiversificationKey.version)
}

// -------------------------------------------------------------------

// MifareKey

// required bytes key = 1;
inline bool MifareKey::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MifareKey::has_key() const {
  return _internal_has_key();
}
inline void MifareKey::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MifareKey::key() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.MifareKey.key)
  return _internal_key();
}
inline void MifareKey::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:mifare.av2.change_keyentry.MifareKey.key)
}
inline std::string* MifareKey::mutable_key() {
  // @@protoc_insertion_point(field_mutable:mifare.av2.change_keyentry.MifareKey.key)
  return _internal_mutable_key();
}
inline const std::string& MifareKey::_internal_key() const {
  return key_.GetNoArena();
}
inline void MifareKey::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void MifareKey::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mifare.av2.change_keyentry.MifareKey.key)
}
inline void MifareKey::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mifare.av2.change_keyentry.MifareKey.key)
}
inline void MifareKey::set_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mifare.av2.change_keyentry.MifareKey.key)
}
inline std::string* MifareKey::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MifareKey::release_key() {
  // @@protoc_insertion_point(field_release:mifare.av2.change_keyentry.MifareKey.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MifareKey::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mifare.av2.change_keyentry.MifareKey.key)
}

// optional .mifare.av2.change_keyentry.MifareKey.DiversificationKey diversification_key = 2;
inline bool MifareKey::_internal_has_diversification_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || diversification_key_ != nullptr);
  return value;
}
inline bool MifareKey::has_diversification_key() const {
  return _internal_has_diversification_key();
}
inline void MifareKey::clear_diversification_key() {
  if (diversification_key_ != nullptr) diversification_key_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mifare::av2::change_keyentry::MifareKey_DiversificationKey& MifareKey::_internal_diversification_key() const {
  const ::mifare::av2::change_keyentry::MifareKey_DiversificationKey* p = diversification_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mifare::av2::change_keyentry::MifareKey_DiversificationKey*>(
      &::mifare::av2::change_keyentry::_MifareKey_DiversificationKey_default_instance_);
}
inline const ::mifare::av2::change_keyentry::MifareKey_DiversificationKey& MifareKey::diversification_key() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.MifareKey.diversification_key)
  return _internal_diversification_key();
}
inline ::mifare::av2::change_keyentry::MifareKey_DiversificationKey* MifareKey::release_diversification_key() {
  // @@protoc_insertion_point(field_release:mifare.av2.change_keyentry.MifareKey.diversification_key)
  _has_bits_[0] &= ~0x00000002u;
  ::mifare::av2::change_keyentry::MifareKey_DiversificationKey* temp = diversification_key_;
  diversification_key_ = nullptr;
  return temp;
}
inline ::mifare::av2::change_keyentry::MifareKey_DiversificationKey* MifareKey::_internal_mutable_diversification_key() {
  _has_bits_[0] |= 0x00000002u;
  if (diversification_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::mifare::av2::change_keyentry::MifareKey_DiversificationKey>(GetArenaNoVirtual());
    diversification_key_ = p;
  }
  return diversification_key_;
}
inline ::mifare::av2::change_keyentry::MifareKey_DiversificationKey* MifareKey::mutable_diversification_key() {
  // @@protoc_insertion_point(field_mutable:mifare.av2.change_keyentry.MifareKey.diversification_key)
  return _internal_mutable_diversification_key();
}
inline void MifareKey::set_allocated_diversification_key(::mifare::av2::change_keyentry::MifareKey_DiversificationKey* diversification_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete diversification_key_;
  }
  if (diversification_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      diversification_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diversification_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  diversification_key_ = diversification_key;
  // @@protoc_insertion_point(field_set_allocated:mifare.av2.change_keyentry.MifareKey.diversification_key)
}

// -------------------------------------------------------------------

// PlusKeyEntry

// required bytes key = 1;
inline bool PlusKeyEntry::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlusKeyEntry::has_key() const {
  return _internal_has_key();
}
inline void PlusKeyEntry::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlusKeyEntry::key() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.PlusKeyEntry.key)
  return _internal_key();
}
inline void PlusKeyEntry::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:mifare.av2.change_keyentry.PlusKeyEntry.key)
}
inline std::string* PlusKeyEntry::mutable_key() {
  // @@protoc_insertion_point(field_mutable:mifare.av2.change_keyentry.PlusKeyEntry.key)
  return _internal_mutable_key();
}
inline const std::string& PlusKeyEntry::_internal_key() const {
  return key_.GetNoArena();
}
inline void PlusKeyEntry::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PlusKeyEntry::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mifare.av2.change_keyentry.PlusKeyEntry.key)
}
inline void PlusKeyEntry::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mifare.av2.change_keyentry.PlusKeyEntry.key)
}
inline void PlusKeyEntry::set_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mifare.av2.change_keyentry.PlusKeyEntry.key)
}
inline std::string* PlusKeyEntry::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PlusKeyEntry::release_key() {
  // @@protoc_insertion_point(field_release:mifare.av2.change_keyentry.PlusKeyEntry.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PlusKeyEntry::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mifare.av2.change_keyentry.PlusKeyEntry.key)
}

// -------------------------------------------------------------------

// UltralightCKeyEntry

// required bytes key = 1;
inline bool UltralightCKeyEntry::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UltralightCKeyEntry::has_key() const {
  return _internal_has_key();
}
inline void UltralightCKeyEntry::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UltralightCKeyEntry::key() const {
  // @@protoc_insertion_point(field_get:mifare.av2.change_keyentry.UltralightCKeyEntry.key)
  return _internal_key();
}
inline void UltralightCKeyEntry::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:mifare.av2.change_keyentry.UltralightCKeyEntry.key)
}
inline std::string* UltralightCKeyEntry::mutable_key() {
  // @@protoc_insertion_point(field_mutable:mifare.av2.change_keyentry.UltralightCKeyEntry.key)
  return _internal_mutable_key();
}
inline const std::string& UltralightCKeyEntry::_internal_key() const {
  return key_.GetNoArena();
}
inline void UltralightCKeyEntry::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void UltralightCKeyEntry::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mifare.av2.change_keyentry.UltralightCKeyEntry.key)
}
inline void UltralightCKeyEntry::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mifare.av2.change_keyentry.UltralightCKeyEntry.key)
}
inline void UltralightCKeyEntry::set_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mifare.av2.change_keyentry.UltralightCKeyEntry.key)
}
inline std::string* UltralightCKeyEntry::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UltralightCKeyEntry::release_key() {
  // @@protoc_insertion_point(field_release:mifare.av2.change_keyentry.UltralightCKeyEntry.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UltralightCKeyEntry::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mifare.av2.change_keyentry.UltralightCKeyEntry.key)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace change_keyentry
}  // namespace av2
}  // namespace mifare

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mifare_2fav2_2fchange_5fkeyentry_2eproto
