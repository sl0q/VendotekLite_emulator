// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mifare/ultralight/bulk.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mifare_2fultralight_2fbulk_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mifare_2fultralight_2fbulk_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "mifare/ultralight/auth.pb.h"
#include "mifare/ultralight/read.pb.h"
#include "mifare/ultralight/write.pb.h"
#include "mifare/ultralight/password.pb.h"
#include "mifare/ultralight/counter/get.pb.h"
#include "mifare/ultralight/counter/increment.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mifare_2fultralight_2fbulk_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mifare_2fultralight_2fbulk_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mifare_2fultralight_2fbulk_2eproto;
namespace mifare {
namespace ultralight {
namespace bulk {
class BulkOperation;
class BulkOperationDefaultTypeInternal;
extern BulkOperationDefaultTypeInternal _BulkOperation_default_instance_;
class BulkResult;
class BulkResultDefaultTypeInternal;
extern BulkResultDefaultTypeInternal _BulkResult_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class CommandResult;
class CommandResultDefaultTypeInternal;
extern CommandResultDefaultTypeInternal _CommandResult_default_instance_;
}  // namespace bulk
}  // namespace ultralight
}  // namespace mifare
PROTOBUF_NAMESPACE_OPEN
template<> ::mifare::ultralight::bulk::BulkOperation* Arena::CreateMaybeMessage<::mifare::ultralight::bulk::BulkOperation>(Arena*);
template<> ::mifare::ultralight::bulk::BulkResult* Arena::CreateMaybeMessage<::mifare::ultralight::bulk::BulkResult>(Arena*);
template<> ::mifare::ultralight::bulk::Command* Arena::CreateMaybeMessage<::mifare::ultralight::bulk::Command>(Arena*);
template<> ::mifare::ultralight::bulk::CommandResult* Arena::CreateMaybeMessage<::mifare::ultralight::bulk::CommandResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mifare {
namespace ultralight {
namespace bulk {

// ===================================================================

class BulkOperation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mifare.ultralight.bulk.BulkOperation) */ {
 public:
  BulkOperation();
  virtual ~BulkOperation();

  BulkOperation(const BulkOperation& from);
  BulkOperation(BulkOperation&& from) noexcept
    : BulkOperation() {
    *this = ::std::move(from);
  }

  inline BulkOperation& operator=(const BulkOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkOperation& operator=(BulkOperation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BulkOperation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BulkOperation* internal_default_instance() {
    return reinterpret_cast<const BulkOperation*>(
               &_BulkOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BulkOperation& a, BulkOperation& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkOperation* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BulkOperation* New() const final {
    return CreateMaybeMessage<BulkOperation>(nullptr);
  }

  BulkOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BulkOperation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BulkOperation& from);
  void MergeFrom(const BulkOperation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkOperation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mifare.ultralight.bulk.BulkOperation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mifare_2fultralight_2fbulk_2eproto);
    return ::descriptor_table_mifare_2fultralight_2fbulk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationsFieldNumber = 1,
  };
  // repeated .mifare.ultralight.bulk.Command operations = 1;
  int operations_size() const;
  private:
  int _internal_operations_size() const;
  public:
  void clear_operations();
  ::mifare::ultralight::bulk::Command* mutable_operations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::ultralight::bulk::Command >*
      mutable_operations();
  private:
  const ::mifare::ultralight::bulk::Command& _internal_operations(int index) const;
  ::mifare::ultralight::bulk::Command* _internal_add_operations();
  public:
  const ::mifare::ultralight::bulk::Command& operations(int index) const;
  ::mifare::ultralight::bulk::Command* add_operations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::ultralight::bulk::Command >&
      operations() const;

  // @@protoc_insertion_point(class_scope:mifare.ultralight.bulk.BulkOperation)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::ultralight::bulk::Command > operations_;
  friend struct ::TableStruct_mifare_2fultralight_2fbulk_2eproto;
};
// -------------------------------------------------------------------

class BulkResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mifare.ultralight.bulk.BulkResult) */ {
 public:
  BulkResult();
  virtual ~BulkResult();

  BulkResult(const BulkResult& from);
  BulkResult(BulkResult&& from) noexcept
    : BulkResult() {
    *this = ::std::move(from);
  }

  inline BulkResult& operator=(const BulkResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkResult& operator=(BulkResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BulkResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BulkResult* internal_default_instance() {
    return reinterpret_cast<const BulkResult*>(
               &_BulkResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BulkResult& a, BulkResult& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BulkResult* New() const final {
    return CreateMaybeMessage<BulkResult>(nullptr);
  }

  BulkResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BulkResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BulkResult& from);
  void MergeFrom(const BulkResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mifare.ultralight.bulk.BulkResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mifare_2fultralight_2fbulk_2eproto);
    return ::descriptor_table_mifare_2fultralight_2fbulk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .mifare.ultralight.bulk.CommandResult results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::mifare::ultralight::bulk::CommandResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::ultralight::bulk::CommandResult >*
      mutable_results();
  private:
  const ::mifare::ultralight::bulk::CommandResult& _internal_results(int index) const;
  ::mifare::ultralight::bulk::CommandResult* _internal_add_results();
  public:
  const ::mifare::ultralight::bulk::CommandResult& results(int index) const;
  ::mifare::ultralight::bulk::CommandResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::ultralight::bulk::CommandResult >&
      results() const;

  // @@protoc_insertion_point(class_scope:mifare.ultralight.bulk.BulkResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::ultralight::bulk::CommandResult > results_;
  friend struct ::TableStruct_mifare_2fultralight_2fbulk_2eproto;
};
// -------------------------------------------------------------------

class Command :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mifare.ultralight.bulk.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Command& default_instance();

  enum MfrCmdCase {
    kReadPages = 1,
    kWritePages = 2,
    kGetCounter = 3,
    kIncrementCounter = 4,
    kAuthOnClearKey = 5,
    kAuthOnSamKey = 6,
    kAuthClearPassword = 7,
    kAuthSamPassword = 8,
    MFRCMD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Command* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mifare.ultralight.bulk.Command";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mifare_2fultralight_2fbulk_2eproto);
    return ::descriptor_table_mifare_2fultralight_2fbulk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadPagesFieldNumber = 1,
    kWritePagesFieldNumber = 2,
    kGetCounterFieldNumber = 3,
    kIncrementCounterFieldNumber = 4,
    kAuthOnClearKeyFieldNumber = 5,
    kAuthOnSamKeyFieldNumber = 6,
    kAuthClearPasswordFieldNumber = 7,
    kAuthSamPasswordFieldNumber = 8,
  };
  // optional .mifare.ultralight.read.ReadPages read_pages = 1;
  bool has_read_pages() const;
  private:
  bool _internal_has_read_pages() const;
  public:
  void clear_read_pages();
  const ::mifare::ultralight::read::ReadPages& read_pages() const;
  ::mifare::ultralight::read::ReadPages* release_read_pages();
  ::mifare::ultralight::read::ReadPages* mutable_read_pages();
  void set_allocated_read_pages(::mifare::ultralight::read::ReadPages* read_pages);
  private:
  const ::mifare::ultralight::read::ReadPages& _internal_read_pages() const;
  ::mifare::ultralight::read::ReadPages* _internal_mutable_read_pages();
  public:

  // optional .mifare.ultralight.write.WritePages write_pages = 2;
  bool has_write_pages() const;
  private:
  bool _internal_has_write_pages() const;
  public:
  void clear_write_pages();
  const ::mifare::ultralight::write::WritePages& write_pages() const;
  ::mifare::ultralight::write::WritePages* release_write_pages();
  ::mifare::ultralight::write::WritePages* mutable_write_pages();
  void set_allocated_write_pages(::mifare::ultralight::write::WritePages* write_pages);
  private:
  const ::mifare::ultralight::write::WritePages& _internal_write_pages() const;
  ::mifare::ultralight::write::WritePages* _internal_mutable_write_pages();
  public:

  // optional .mifare.ultralight.counter.get.GetCounter get_counter = 3;
  bool has_get_counter() const;
  private:
  bool _internal_has_get_counter() const;
  public:
  void clear_get_counter();
  const ::mifare::ultralight::counter::get::GetCounter& get_counter() const;
  ::mifare::ultralight::counter::get::GetCounter* release_get_counter();
  ::mifare::ultralight::counter::get::GetCounter* mutable_get_counter();
  void set_allocated_get_counter(::mifare::ultralight::counter::get::GetCounter* get_counter);
  private:
  const ::mifare::ultralight::counter::get::GetCounter& _internal_get_counter() const;
  ::mifare::ultralight::counter::get::GetCounter* _internal_mutable_get_counter();
  public:

  // optional .mifare.ultralight.counter.increment.IncrementCounter increment_counter = 4;
  bool has_increment_counter() const;
  private:
  bool _internal_has_increment_counter() const;
  public:
  void clear_increment_counter();
  const ::mifare::ultralight::counter::increment::IncrementCounter& increment_counter() const;
  ::mifare::ultralight::counter::increment::IncrementCounter* release_increment_counter();
  ::mifare::ultralight::counter::increment::IncrementCounter* mutable_increment_counter();
  void set_allocated_increment_counter(::mifare::ultralight::counter::increment::IncrementCounter* increment_counter);
  private:
  const ::mifare::ultralight::counter::increment::IncrementCounter& _internal_increment_counter() const;
  ::mifare::ultralight::counter::increment::IncrementCounter* _internal_mutable_increment_counter();
  public:

  // optional .mifare.ultralight.auth.ClearKey auth_on_clear_key = 5;
  bool has_auth_on_clear_key() const;
  private:
  bool _internal_has_auth_on_clear_key() const;
  public:
  void clear_auth_on_clear_key();
  const ::mifare::ultralight::auth::ClearKey& auth_on_clear_key() const;
  ::mifare::ultralight::auth::ClearKey* release_auth_on_clear_key();
  ::mifare::ultralight::auth::ClearKey* mutable_auth_on_clear_key();
  void set_allocated_auth_on_clear_key(::mifare::ultralight::auth::ClearKey* auth_on_clear_key);
  private:
  const ::mifare::ultralight::auth::ClearKey& _internal_auth_on_clear_key() const;
  ::mifare::ultralight::auth::ClearKey* _internal_mutable_auth_on_clear_key();
  public:

  // optional .mifare.ultralight.auth.SamKey auth_on_sam_key = 6;
  bool has_auth_on_sam_key() const;
  private:
  bool _internal_has_auth_on_sam_key() const;
  public:
  void clear_auth_on_sam_key();
  const ::mifare::ultralight::auth::SamKey& auth_on_sam_key() const;
  ::mifare::ultralight::auth::SamKey* release_auth_on_sam_key();
  ::mifare::ultralight::auth::SamKey* mutable_auth_on_sam_key();
  void set_allocated_auth_on_sam_key(::mifare::ultralight::auth::SamKey* auth_on_sam_key);
  private:
  const ::mifare::ultralight::auth::SamKey& _internal_auth_on_sam_key() const;
  ::mifare::ultralight::auth::SamKey* _internal_mutable_auth_on_sam_key();
  public:

  // optional .mifare.ultralight.password.ClearPassword auth_clear_password = 7;
  bool has_auth_clear_password() const;
  private:
  bool _internal_has_auth_clear_password() const;
  public:
  void clear_auth_clear_password();
  const ::mifare::ultralight::password::ClearPassword& auth_clear_password() const;
  ::mifare::ultralight::password::ClearPassword* release_auth_clear_password();
  ::mifare::ultralight::password::ClearPassword* mutable_auth_clear_password();
  void set_allocated_auth_clear_password(::mifare::ultralight::password::ClearPassword* auth_clear_password);
  private:
  const ::mifare::ultralight::password::ClearPassword& _internal_auth_clear_password() const;
  ::mifare::ultralight::password::ClearPassword* _internal_mutable_auth_clear_password();
  public:

  // optional .mifare.ultralight.password.SamPassword auth_sam_password = 8;
  bool has_auth_sam_password() const;
  private:
  bool _internal_has_auth_sam_password() const;
  public:
  void clear_auth_sam_password();
  const ::mifare::ultralight::password::SamPassword& auth_sam_password() const;
  ::mifare::ultralight::password::SamPassword* release_auth_sam_password();
  ::mifare::ultralight::password::SamPassword* mutable_auth_sam_password();
  void set_allocated_auth_sam_password(::mifare::ultralight::password::SamPassword* auth_sam_password);
  private:
  const ::mifare::ultralight::password::SamPassword& _internal_auth_sam_password() const;
  ::mifare::ultralight::password::SamPassword* _internal_mutable_auth_sam_password();
  public:

  void clear_MfrCmd();
  MfrCmdCase MfrCmd_case() const;
  // @@protoc_insertion_point(class_scope:mifare.ultralight.bulk.Command)
 private:
  class _Internal;
  void set_has_read_pages();
  void set_has_write_pages();
  void set_has_get_counter();
  void set_has_increment_counter();
  void set_has_auth_on_clear_key();
  void set_has_auth_on_sam_key();
  void set_has_auth_clear_password();
  void set_has_auth_sam_password();

  inline bool has_MfrCmd() const;
  inline void clear_has_MfrCmd();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  union MfrCmdUnion {
    MfrCmdUnion() {}
    ::mifare::ultralight::read::ReadPages* read_pages_;
    ::mifare::ultralight::write::WritePages* write_pages_;
    ::mifare::ultralight::counter::get::GetCounter* get_counter_;
    ::mifare::ultralight::counter::increment::IncrementCounter* increment_counter_;
    ::mifare::ultralight::auth::ClearKey* auth_on_clear_key_;
    ::mifare::ultralight::auth::SamKey* auth_on_sam_key_;
    ::mifare::ultralight::password::ClearPassword* auth_clear_password_;
    ::mifare::ultralight::password::SamPassword* auth_sam_password_;
  } MfrCmd_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_mifare_2fultralight_2fbulk_2eproto;
};
// -------------------------------------------------------------------

class CommandResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mifare.ultralight.bulk.CommandResult) */ {
 public:
  CommandResult();
  virtual ~CommandResult();

  CommandResult(const CommandResult& from);
  CommandResult(CommandResult&& from) noexcept
    : CommandResult() {
    *this = ::std::move(from);
  }

  inline CommandResult& operator=(const CommandResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandResult& operator=(CommandResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandResult& default_instance();

  enum MfrResultCase {
    kPages = 1,
    kCounterValue = 2,
    MFRRESULT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandResult* internal_default_instance() {
    return reinterpret_cast<const CommandResult*>(
               &_CommandResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CommandResult& a, CommandResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandResult* New() const final {
    return CreateMaybeMessage<CommandResult>(nullptr);
  }

  CommandResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandResult& from);
  void MergeFrom(const CommandResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mifare.ultralight.bulk.CommandResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mifare_2fultralight_2fbulk_2eproto);
    return ::descriptor_table_mifare_2fultralight_2fbulk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPagesFieldNumber = 1,
    kCounterValueFieldNumber = 2,
  };
  // optional .mifare.ultralight.read.Pages pages = 1;
  bool has_pages() const;
  private:
  bool _internal_has_pages() const;
  public:
  void clear_pages();
  const ::mifare::ultralight::read::Pages& pages() const;
  ::mifare::ultralight::read::Pages* release_pages();
  ::mifare::ultralight::read::Pages* mutable_pages();
  void set_allocated_pages(::mifare::ultralight::read::Pages* pages);
  private:
  const ::mifare::ultralight::read::Pages& _internal_pages() const;
  ::mifare::ultralight::read::Pages* _internal_mutable_pages();
  public:

  // optional .mifare.ultralight.counter.get.CounterValue counter_value = 2;
  bool has_counter_value() const;
  private:
  bool _internal_has_counter_value() const;
  public:
  void clear_counter_value();
  const ::mifare::ultralight::counter::get::CounterValue& counter_value() const;
  ::mifare::ultralight::counter::get::CounterValue* release_counter_value();
  ::mifare::ultralight::counter::get::CounterValue* mutable_counter_value();
  void set_allocated_counter_value(::mifare::ultralight::counter::get::CounterValue* counter_value);
  private:
  const ::mifare::ultralight::counter::get::CounterValue& _internal_counter_value() const;
  ::mifare::ultralight::counter::get::CounterValue* _internal_mutable_counter_value();
  public:

  void clear_MfrResult();
  MfrResultCase MfrResult_case() const;
  // @@protoc_insertion_point(class_scope:mifare.ultralight.bulk.CommandResult)
 private:
  class _Internal;
  void set_has_pages();
  void set_has_counter_value();

  inline bool has_MfrResult() const;
  inline void clear_has_MfrResult();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  union MfrResultUnion {
    MfrResultUnion() {}
    ::mifare::ultralight::read::Pages* pages_;
    ::mifare::ultralight::counter::get::CounterValue* counter_value_;
  } MfrResult_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_mifare_2fultralight_2fbulk_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BulkOperation

// repeated .mifare.ultralight.bulk.Command operations = 1;
inline int BulkOperation::_internal_operations_size() const {
  return operations_.size();
}
inline int BulkOperation::operations_size() const {
  return _internal_operations_size();
}
inline void BulkOperation::clear_operations() {
  operations_.Clear();
}
inline ::mifare::ultralight::bulk::Command* BulkOperation::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:mifare.ultralight.bulk.BulkOperation.operations)
  return operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::ultralight::bulk::Command >*
BulkOperation::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:mifare.ultralight.bulk.BulkOperation.operations)
  return &operations_;
}
inline const ::mifare::ultralight::bulk::Command& BulkOperation::_internal_operations(int index) const {
  return operations_.Get(index);
}
inline const ::mifare::ultralight::bulk::Command& BulkOperation::operations(int index) const {
  // @@protoc_insertion_point(field_get:mifare.ultralight.bulk.BulkOperation.operations)
  return _internal_operations(index);
}
inline ::mifare::ultralight::bulk::Command* BulkOperation::_internal_add_operations() {
  return operations_.Add();
}
inline ::mifare::ultralight::bulk::Command* BulkOperation::add_operations() {
  // @@protoc_insertion_point(field_add:mifare.ultralight.bulk.BulkOperation.operations)
  return _internal_add_operations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::ultralight::bulk::Command >&
BulkOperation::operations() const {
  // @@protoc_insertion_point(field_list:mifare.ultralight.bulk.BulkOperation.operations)
  return operations_;
}

// -------------------------------------------------------------------

// BulkResult

// repeated .mifare.ultralight.bulk.CommandResult results = 1;
inline int BulkResult::_internal_results_size() const {
  return results_.size();
}
inline int BulkResult::results_size() const {
  return _internal_results_size();
}
inline void BulkResult::clear_results() {
  results_.Clear();
}
inline ::mifare::ultralight::bulk::CommandResult* BulkResult::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:mifare.ultralight.bulk.BulkResult.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::ultralight::bulk::CommandResult >*
BulkResult::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:mifare.ultralight.bulk.BulkResult.results)
  return &results_;
}
inline const ::mifare::ultralight::bulk::CommandResult& BulkResult::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::mifare::ultralight::bulk::CommandResult& BulkResult::results(int index) const {
  // @@protoc_insertion_point(field_get:mifare.ultralight.bulk.BulkResult.results)
  return _internal_results(index);
}
inline ::mifare::ultralight::bulk::CommandResult* BulkResult::_internal_add_results() {
  return results_.Add();
}
inline ::mifare::ultralight::bulk::CommandResult* BulkResult::add_results() {
  // @@protoc_insertion_point(field_add:mifare.ultralight.bulk.BulkResult.results)
  return _internal_add_results();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::ultralight::bulk::CommandResult >&
BulkResult::results() const {
  // @@protoc_insertion_point(field_list:mifare.ultralight.bulk.BulkResult.results)
  return results_;
}

// -------------------------------------------------------------------

// Command

// optional .mifare.ultralight.read.ReadPages read_pages = 1;
inline bool Command::_internal_has_read_pages() const {
  return MfrCmd_case() == kReadPages;
}
inline bool Command::has_read_pages() const {
  return _internal_has_read_pages();
}
inline void Command::set_has_read_pages() {
  _oneof_case_[0] = kReadPages;
}
inline ::mifare::ultralight::read::ReadPages* Command::release_read_pages() {
  // @@protoc_insertion_point(field_release:mifare.ultralight.bulk.Command.read_pages)
  if (_internal_has_read_pages()) {
    clear_has_MfrCmd();
      ::mifare::ultralight::read::ReadPages* temp = MfrCmd_.read_pages_;
    MfrCmd_.read_pages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::ultralight::read::ReadPages& Command::_internal_read_pages() const {
  return _internal_has_read_pages()
      ? *MfrCmd_.read_pages_
      : *reinterpret_cast< ::mifare::ultralight::read::ReadPages*>(&::mifare::ultralight::read::_ReadPages_default_instance_);
}
inline const ::mifare::ultralight::read::ReadPages& Command::read_pages() const {
  // @@protoc_insertion_point(field_get:mifare.ultralight.bulk.Command.read_pages)
  return _internal_read_pages();
}
inline ::mifare::ultralight::read::ReadPages* Command::_internal_mutable_read_pages() {
  if (!_internal_has_read_pages()) {
    clear_MfrCmd();
    set_has_read_pages();
    MfrCmd_.read_pages_ = CreateMaybeMessage< ::mifare::ultralight::read::ReadPages >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.read_pages_;
}
inline ::mifare::ultralight::read::ReadPages* Command::mutable_read_pages() {
  // @@protoc_insertion_point(field_mutable:mifare.ultralight.bulk.Command.read_pages)
  return _internal_mutable_read_pages();
}

// optional .mifare.ultralight.write.WritePages write_pages = 2;
inline bool Command::_internal_has_write_pages() const {
  return MfrCmd_case() == kWritePages;
}
inline bool Command::has_write_pages() const {
  return _internal_has_write_pages();
}
inline void Command::set_has_write_pages() {
  _oneof_case_[0] = kWritePages;
}
inline ::mifare::ultralight::write::WritePages* Command::release_write_pages() {
  // @@protoc_insertion_point(field_release:mifare.ultralight.bulk.Command.write_pages)
  if (_internal_has_write_pages()) {
    clear_has_MfrCmd();
      ::mifare::ultralight::write::WritePages* temp = MfrCmd_.write_pages_;
    MfrCmd_.write_pages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::ultralight::write::WritePages& Command::_internal_write_pages() const {
  return _internal_has_write_pages()
      ? *MfrCmd_.write_pages_
      : *reinterpret_cast< ::mifare::ultralight::write::WritePages*>(&::mifare::ultralight::write::_WritePages_default_instance_);
}
inline const ::mifare::ultralight::write::WritePages& Command::write_pages() const {
  // @@protoc_insertion_point(field_get:mifare.ultralight.bulk.Command.write_pages)
  return _internal_write_pages();
}
inline ::mifare::ultralight::write::WritePages* Command::_internal_mutable_write_pages() {
  if (!_internal_has_write_pages()) {
    clear_MfrCmd();
    set_has_write_pages();
    MfrCmd_.write_pages_ = CreateMaybeMessage< ::mifare::ultralight::write::WritePages >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.write_pages_;
}
inline ::mifare::ultralight::write::WritePages* Command::mutable_write_pages() {
  // @@protoc_insertion_point(field_mutable:mifare.ultralight.bulk.Command.write_pages)
  return _internal_mutable_write_pages();
}

// optional .mifare.ultralight.counter.get.GetCounter get_counter = 3;
inline bool Command::_internal_has_get_counter() const {
  return MfrCmd_case() == kGetCounter;
}
inline bool Command::has_get_counter() const {
  return _internal_has_get_counter();
}
inline void Command::set_has_get_counter() {
  _oneof_case_[0] = kGetCounter;
}
inline ::mifare::ultralight::counter::get::GetCounter* Command::release_get_counter() {
  // @@protoc_insertion_point(field_release:mifare.ultralight.bulk.Command.get_counter)
  if (_internal_has_get_counter()) {
    clear_has_MfrCmd();
      ::mifare::ultralight::counter::get::GetCounter* temp = MfrCmd_.get_counter_;
    MfrCmd_.get_counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::ultralight::counter::get::GetCounter& Command::_internal_get_counter() const {
  return _internal_has_get_counter()
      ? *MfrCmd_.get_counter_
      : *reinterpret_cast< ::mifare::ultralight::counter::get::GetCounter*>(&::mifare::ultralight::counter::get::_GetCounter_default_instance_);
}
inline const ::mifare::ultralight::counter::get::GetCounter& Command::get_counter() const {
  // @@protoc_insertion_point(field_get:mifare.ultralight.bulk.Command.get_counter)
  return _internal_get_counter();
}
inline ::mifare::ultralight::counter::get::GetCounter* Command::_internal_mutable_get_counter() {
  if (!_internal_has_get_counter()) {
    clear_MfrCmd();
    set_has_get_counter();
    MfrCmd_.get_counter_ = CreateMaybeMessage< ::mifare::ultralight::counter::get::GetCounter >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.get_counter_;
}
inline ::mifare::ultralight::counter::get::GetCounter* Command::mutable_get_counter() {
  // @@protoc_insertion_point(field_mutable:mifare.ultralight.bulk.Command.get_counter)
  return _internal_mutable_get_counter();
}

// optional .mifare.ultralight.counter.increment.IncrementCounter increment_counter = 4;
inline bool Command::_internal_has_increment_counter() const {
  return MfrCmd_case() == kIncrementCounter;
}
inline bool Command::has_increment_counter() const {
  return _internal_has_increment_counter();
}
inline void Command::set_has_increment_counter() {
  _oneof_case_[0] = kIncrementCounter;
}
inline ::mifare::ultralight::counter::increment::IncrementCounter* Command::release_increment_counter() {
  // @@protoc_insertion_point(field_release:mifare.ultralight.bulk.Command.increment_counter)
  if (_internal_has_increment_counter()) {
    clear_has_MfrCmd();
      ::mifare::ultralight::counter::increment::IncrementCounter* temp = MfrCmd_.increment_counter_;
    MfrCmd_.increment_counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::ultralight::counter::increment::IncrementCounter& Command::_internal_increment_counter() const {
  return _internal_has_increment_counter()
      ? *MfrCmd_.increment_counter_
      : *reinterpret_cast< ::mifare::ultralight::counter::increment::IncrementCounter*>(&::mifare::ultralight::counter::increment::_IncrementCounter_default_instance_);
}
inline const ::mifare::ultralight::counter::increment::IncrementCounter& Command::increment_counter() const {
  // @@protoc_insertion_point(field_get:mifare.ultralight.bulk.Command.increment_counter)
  return _internal_increment_counter();
}
inline ::mifare::ultralight::counter::increment::IncrementCounter* Command::_internal_mutable_increment_counter() {
  if (!_internal_has_increment_counter()) {
    clear_MfrCmd();
    set_has_increment_counter();
    MfrCmd_.increment_counter_ = CreateMaybeMessage< ::mifare::ultralight::counter::increment::IncrementCounter >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.increment_counter_;
}
inline ::mifare::ultralight::counter::increment::IncrementCounter* Command::mutable_increment_counter() {
  // @@protoc_insertion_point(field_mutable:mifare.ultralight.bulk.Command.increment_counter)
  return _internal_mutable_increment_counter();
}

// optional .mifare.ultralight.auth.ClearKey auth_on_clear_key = 5;
inline bool Command::_internal_has_auth_on_clear_key() const {
  return MfrCmd_case() == kAuthOnClearKey;
}
inline bool Command::has_auth_on_clear_key() const {
  return _internal_has_auth_on_clear_key();
}
inline void Command::set_has_auth_on_clear_key() {
  _oneof_case_[0] = kAuthOnClearKey;
}
inline ::mifare::ultralight::auth::ClearKey* Command::release_auth_on_clear_key() {
  // @@protoc_insertion_point(field_release:mifare.ultralight.bulk.Command.auth_on_clear_key)
  if (_internal_has_auth_on_clear_key()) {
    clear_has_MfrCmd();
      ::mifare::ultralight::auth::ClearKey* temp = MfrCmd_.auth_on_clear_key_;
    MfrCmd_.auth_on_clear_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::ultralight::auth::ClearKey& Command::_internal_auth_on_clear_key() const {
  return _internal_has_auth_on_clear_key()
      ? *MfrCmd_.auth_on_clear_key_
      : *reinterpret_cast< ::mifare::ultralight::auth::ClearKey*>(&::mifare::ultralight::auth::_ClearKey_default_instance_);
}
inline const ::mifare::ultralight::auth::ClearKey& Command::auth_on_clear_key() const {
  // @@protoc_insertion_point(field_get:mifare.ultralight.bulk.Command.auth_on_clear_key)
  return _internal_auth_on_clear_key();
}
inline ::mifare::ultralight::auth::ClearKey* Command::_internal_mutable_auth_on_clear_key() {
  if (!_internal_has_auth_on_clear_key()) {
    clear_MfrCmd();
    set_has_auth_on_clear_key();
    MfrCmd_.auth_on_clear_key_ = CreateMaybeMessage< ::mifare::ultralight::auth::ClearKey >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.auth_on_clear_key_;
}
inline ::mifare::ultralight::auth::ClearKey* Command::mutable_auth_on_clear_key() {
  // @@protoc_insertion_point(field_mutable:mifare.ultralight.bulk.Command.auth_on_clear_key)
  return _internal_mutable_auth_on_clear_key();
}

// optional .mifare.ultralight.auth.SamKey auth_on_sam_key = 6;
inline bool Command::_internal_has_auth_on_sam_key() const {
  return MfrCmd_case() == kAuthOnSamKey;
}
inline bool Command::has_auth_on_sam_key() const {
  return _internal_has_auth_on_sam_key();
}
inline void Command::set_has_auth_on_sam_key() {
  _oneof_case_[0] = kAuthOnSamKey;
}
inline ::mifare::ultralight::auth::SamKey* Command::release_auth_on_sam_key() {
  // @@protoc_insertion_point(field_release:mifare.ultralight.bulk.Command.auth_on_sam_key)
  if (_internal_has_auth_on_sam_key()) {
    clear_has_MfrCmd();
      ::mifare::ultralight::auth::SamKey* temp = MfrCmd_.auth_on_sam_key_;
    MfrCmd_.auth_on_sam_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::ultralight::auth::SamKey& Command::_internal_auth_on_sam_key() const {
  return _internal_has_auth_on_sam_key()
      ? *MfrCmd_.auth_on_sam_key_
      : *reinterpret_cast< ::mifare::ultralight::auth::SamKey*>(&::mifare::ultralight::auth::_SamKey_default_instance_);
}
inline const ::mifare::ultralight::auth::SamKey& Command::auth_on_sam_key() const {
  // @@protoc_insertion_point(field_get:mifare.ultralight.bulk.Command.auth_on_sam_key)
  return _internal_auth_on_sam_key();
}
inline ::mifare::ultralight::auth::SamKey* Command::_internal_mutable_auth_on_sam_key() {
  if (!_internal_has_auth_on_sam_key()) {
    clear_MfrCmd();
    set_has_auth_on_sam_key();
    MfrCmd_.auth_on_sam_key_ = CreateMaybeMessage< ::mifare::ultralight::auth::SamKey >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.auth_on_sam_key_;
}
inline ::mifare::ultralight::auth::SamKey* Command::mutable_auth_on_sam_key() {
  // @@protoc_insertion_point(field_mutable:mifare.ultralight.bulk.Command.auth_on_sam_key)
  return _internal_mutable_auth_on_sam_key();
}

// optional .mifare.ultralight.password.ClearPassword auth_clear_password = 7;
inline bool Command::_internal_has_auth_clear_password() const {
  return MfrCmd_case() == kAuthClearPassword;
}
inline bool Command::has_auth_clear_password() const {
  return _internal_has_auth_clear_password();
}
inline void Command::set_has_auth_clear_password() {
  _oneof_case_[0] = kAuthClearPassword;
}
inline ::mifare::ultralight::password::ClearPassword* Command::release_auth_clear_password() {
  // @@protoc_insertion_point(field_release:mifare.ultralight.bulk.Command.auth_clear_password)
  if (_internal_has_auth_clear_password()) {
    clear_has_MfrCmd();
      ::mifare::ultralight::password::ClearPassword* temp = MfrCmd_.auth_clear_password_;
    MfrCmd_.auth_clear_password_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::ultralight::password::ClearPassword& Command::_internal_auth_clear_password() const {
  return _internal_has_auth_clear_password()
      ? *MfrCmd_.auth_clear_password_
      : *reinterpret_cast< ::mifare::ultralight::password::ClearPassword*>(&::mifare::ultralight::password::_ClearPassword_default_instance_);
}
inline const ::mifare::ultralight::password::ClearPassword& Command::auth_clear_password() const {
  // @@protoc_insertion_point(field_get:mifare.ultralight.bulk.Command.auth_clear_password)
  return _internal_auth_clear_password();
}
inline ::mifare::ultralight::password::ClearPassword* Command::_internal_mutable_auth_clear_password() {
  if (!_internal_has_auth_clear_password()) {
    clear_MfrCmd();
    set_has_auth_clear_password();
    MfrCmd_.auth_clear_password_ = CreateMaybeMessage< ::mifare::ultralight::password::ClearPassword >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.auth_clear_password_;
}
inline ::mifare::ultralight::password::ClearPassword* Command::mutable_auth_clear_password() {
  // @@protoc_insertion_point(field_mutable:mifare.ultralight.bulk.Command.auth_clear_password)
  return _internal_mutable_auth_clear_password();
}

// optional .mifare.ultralight.password.SamPassword auth_sam_password = 8;
inline bool Command::_internal_has_auth_sam_password() const {
  return MfrCmd_case() == kAuthSamPassword;
}
inline bool Command::has_auth_sam_password() const {
  return _internal_has_auth_sam_password();
}
inline void Command::set_has_auth_sam_password() {
  _oneof_case_[0] = kAuthSamPassword;
}
inline ::mifare::ultralight::password::SamPassword* Command::release_auth_sam_password() {
  // @@protoc_insertion_point(field_release:mifare.ultralight.bulk.Command.auth_sam_password)
  if (_internal_has_auth_sam_password()) {
    clear_has_MfrCmd();
      ::mifare::ultralight::password::SamPassword* temp = MfrCmd_.auth_sam_password_;
    MfrCmd_.auth_sam_password_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::ultralight::password::SamPassword& Command::_internal_auth_sam_password() const {
  return _internal_has_auth_sam_password()
      ? *MfrCmd_.auth_sam_password_
      : *reinterpret_cast< ::mifare::ultralight::password::SamPassword*>(&::mifare::ultralight::password::_SamPassword_default_instance_);
}
inline const ::mifare::ultralight::password::SamPassword& Command::auth_sam_password() const {
  // @@protoc_insertion_point(field_get:mifare.ultralight.bulk.Command.auth_sam_password)
  return _internal_auth_sam_password();
}
inline ::mifare::ultralight::password::SamPassword* Command::_internal_mutable_auth_sam_password() {
  if (!_internal_has_auth_sam_password()) {
    clear_MfrCmd();
    set_has_auth_sam_password();
    MfrCmd_.auth_sam_password_ = CreateMaybeMessage< ::mifare::ultralight::password::SamPassword >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.auth_sam_password_;
}
inline ::mifare::ultralight::password::SamPassword* Command::mutable_auth_sam_password() {
  // @@protoc_insertion_point(field_mutable:mifare.ultralight.bulk.Command.auth_sam_password)
  return _internal_mutable_auth_sam_password();
}

inline bool Command::has_MfrCmd() const {
  return MfrCmd_case() != MFRCMD_NOT_SET;
}
inline void Command::clear_has_MfrCmd() {
  _oneof_case_[0] = MFRCMD_NOT_SET;
}
inline Command::MfrCmdCase Command::MfrCmd_case() const {
  return Command::MfrCmdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CommandResult

// optional .mifare.ultralight.read.Pages pages = 1;
inline bool CommandResult::_internal_has_pages() const {
  return MfrResult_case() == kPages;
}
inline bool CommandResult::has_pages() const {
  return _internal_has_pages();
}
inline void CommandResult::set_has_pages() {
  _oneof_case_[0] = kPages;
}
inline ::mifare::ultralight::read::Pages* CommandResult::release_pages() {
  // @@protoc_insertion_point(field_release:mifare.ultralight.bulk.CommandResult.pages)
  if (_internal_has_pages()) {
    clear_has_MfrResult();
      ::mifare::ultralight::read::Pages* temp = MfrResult_.pages_;
    MfrResult_.pages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::ultralight::read::Pages& CommandResult::_internal_pages() const {
  return _internal_has_pages()
      ? *MfrResult_.pages_
      : *reinterpret_cast< ::mifare::ultralight::read::Pages*>(&::mifare::ultralight::read::_Pages_default_instance_);
}
inline const ::mifare::ultralight::read::Pages& CommandResult::pages() const {
  // @@protoc_insertion_point(field_get:mifare.ultralight.bulk.CommandResult.pages)
  return _internal_pages();
}
inline ::mifare::ultralight::read::Pages* CommandResult::_internal_mutable_pages() {
  if (!_internal_has_pages()) {
    clear_MfrResult();
    set_has_pages();
    MfrResult_.pages_ = CreateMaybeMessage< ::mifare::ultralight::read::Pages >(
        GetArenaNoVirtual());
  }
  return MfrResult_.pages_;
}
inline ::mifare::ultralight::read::Pages* CommandResult::mutable_pages() {
  // @@protoc_insertion_point(field_mutable:mifare.ultralight.bulk.CommandResult.pages)
  return _internal_mutable_pages();
}

// optional .mifare.ultralight.counter.get.CounterValue counter_value = 2;
inline bool CommandResult::_internal_has_counter_value() const {
  return MfrResult_case() == kCounterValue;
}
inline bool CommandResult::has_counter_value() const {
  return _internal_has_counter_value();
}
inline void CommandResult::set_has_counter_value() {
  _oneof_case_[0] = kCounterValue;
}
inline ::mifare::ultralight::counter::get::CounterValue* CommandResult::release_counter_value() {
  // @@protoc_insertion_point(field_release:mifare.ultralight.bulk.CommandResult.counter_value)
  if (_internal_has_counter_value()) {
    clear_has_MfrResult();
      ::mifare::ultralight::counter::get::CounterValue* temp = MfrResult_.counter_value_;
    MfrResult_.counter_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::ultralight::counter::get::CounterValue& CommandResult::_internal_counter_value() const {
  return _internal_has_counter_value()
      ? *MfrResult_.counter_value_
      : *reinterpret_cast< ::mifare::ultralight::counter::get::CounterValue*>(&::mifare::ultralight::counter::get::_CounterValue_default_instance_);
}
inline const ::mifare::ultralight::counter::get::CounterValue& CommandResult::counter_value() const {
  // @@protoc_insertion_point(field_get:mifare.ultralight.bulk.CommandResult.counter_value)
  return _internal_counter_value();
}
inline ::mifare::ultralight::counter::get::CounterValue* CommandResult::_internal_mutable_counter_value() {
  if (!_internal_has_counter_value()) {
    clear_MfrResult();
    set_has_counter_value();
    MfrResult_.counter_value_ = CreateMaybeMessage< ::mifare::ultralight::counter::get::CounterValue >(
        GetArenaNoVirtual());
  }
  return MfrResult_.counter_value_;
}
inline ::mifare::ultralight::counter::get::CounterValue* CommandResult::mutable_counter_value() {
  // @@protoc_insertion_point(field_mutable:mifare.ultralight.bulk.CommandResult.counter_value)
  return _internal_mutable_counter_value();
}

inline bool CommandResult::has_MfrResult() const {
  return MfrResult_case() != MFRRESULT_NOT_SET;
}
inline void CommandResult::clear_has_MfrResult() {
  _oneof_case_[0] = MFRRESULT_NOT_SET;
}
inline CommandResult::MfrResultCase CommandResult::MfrResult_case() const {
  return CommandResult::MfrResultCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bulk
}  // namespace ultralight
}  // namespace mifare

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mifare_2fultralight_2fbulk_2eproto
