// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mifare/plus/bulk.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mifare_2fplus_2fbulk_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mifare_2fplus_2fbulk_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "mifare/plus/auth.pb.h"
#include "mifare/plus/read.pb.h"
#include "mifare/plus/write.pb.h"
#include "mifare/plus/counter/commit.pb.h"
#include "mifare/plus/counter/copy.pb.h"
#include "mifare/plus/counter/get.pb.h"
#include "mifare/plus/counter/modify.pb.h"
#include "mifare/plus/counter/set.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mifare_2fplus_2fbulk_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mifare_2fplus_2fbulk_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mifare_2fplus_2fbulk_2eproto;
namespace mifare {
namespace plus {
namespace bulk {
class BulkOperation;
class BulkOperationDefaultTypeInternal;
extern BulkOperationDefaultTypeInternal _BulkOperation_default_instance_;
class BulkResult;
class BulkResultDefaultTypeInternal;
extern BulkResultDefaultTypeInternal _BulkResult_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class CommandResult;
class CommandResultDefaultTypeInternal;
extern CommandResultDefaultTypeInternal _CommandResult_default_instance_;
}  // namespace bulk
}  // namespace plus
}  // namespace mifare
PROTOBUF_NAMESPACE_OPEN
template<> ::mifare::plus::bulk::BulkOperation* Arena::CreateMaybeMessage<::mifare::plus::bulk::BulkOperation>(Arena*);
template<> ::mifare::plus::bulk::BulkResult* Arena::CreateMaybeMessage<::mifare::plus::bulk::BulkResult>(Arena*);
template<> ::mifare::plus::bulk::Command* Arena::CreateMaybeMessage<::mifare::plus::bulk::Command>(Arena*);
template<> ::mifare::plus::bulk::CommandResult* Arena::CreateMaybeMessage<::mifare::plus::bulk::CommandResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mifare {
namespace plus {
namespace bulk {

// ===================================================================

class Command :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mifare.plus.bulk.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Command& default_instance();

  enum MfrCmdCase {
    kAuthOnClearKey = 1,
    kReadBlocks = 2,
    kWriteBlocks = 3,
    kGetCounter = 4,
    kSetCounter = 5,
    kModifyCounter = 6,
    kCopyCounter = 7,
    kCommitCounter = 8,
    kAuthOnSamKey = 9,
    MFRCMD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Command* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mifare.plus.bulk.Command";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mifare_2fplus_2fbulk_2eproto);
    return ::descriptor_table_mifare_2fplus_2fbulk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthOnClearKeyFieldNumber = 1,
    kReadBlocksFieldNumber = 2,
    kWriteBlocksFieldNumber = 3,
    kGetCounterFieldNumber = 4,
    kSetCounterFieldNumber = 5,
    kModifyCounterFieldNumber = 6,
    kCopyCounterFieldNumber = 7,
    kCommitCounterFieldNumber = 8,
    kAuthOnSamKeyFieldNumber = 9,
  };
  // optional .mifare.plus.auth.ClearKey auth_on_clear_key = 1;
  bool has_auth_on_clear_key() const;
  private:
  bool _internal_has_auth_on_clear_key() const;
  public:
  void clear_auth_on_clear_key();
  const ::mifare::plus::auth::ClearKey& auth_on_clear_key() const;
  ::mifare::plus::auth::ClearKey* release_auth_on_clear_key();
  ::mifare::plus::auth::ClearKey* mutable_auth_on_clear_key();
  void set_allocated_auth_on_clear_key(::mifare::plus::auth::ClearKey* auth_on_clear_key);
  private:
  const ::mifare::plus::auth::ClearKey& _internal_auth_on_clear_key() const;
  ::mifare::plus::auth::ClearKey* _internal_mutable_auth_on_clear_key();
  public:

  // optional .mifare.plus.read.ReadBlocks read_blocks = 2;
  bool has_read_blocks() const;
  private:
  bool _internal_has_read_blocks() const;
  public:
  void clear_read_blocks();
  const ::mifare::plus::read::ReadBlocks& read_blocks() const;
  ::mifare::plus::read::ReadBlocks* release_read_blocks();
  ::mifare::plus::read::ReadBlocks* mutable_read_blocks();
  void set_allocated_read_blocks(::mifare::plus::read::ReadBlocks* read_blocks);
  private:
  const ::mifare::plus::read::ReadBlocks& _internal_read_blocks() const;
  ::mifare::plus::read::ReadBlocks* _internal_mutable_read_blocks();
  public:

  // optional .mifare.plus.write.WriteBlocks write_blocks = 3;
  bool has_write_blocks() const;
  private:
  bool _internal_has_write_blocks() const;
  public:
  void clear_write_blocks();
  const ::mifare::plus::write::WriteBlocks& write_blocks() const;
  ::mifare::plus::write::WriteBlocks* release_write_blocks();
  ::mifare::plus::write::WriteBlocks* mutable_write_blocks();
  void set_allocated_write_blocks(::mifare::plus::write::WriteBlocks* write_blocks);
  private:
  const ::mifare::plus::write::WriteBlocks& _internal_write_blocks() const;
  ::mifare::plus::write::WriteBlocks* _internal_mutable_write_blocks();
  public:

  // optional .mifare.plus.counter.get.GetCounter get_counter = 4;
  bool has_get_counter() const;
  private:
  bool _internal_has_get_counter() const;
  public:
  void clear_get_counter();
  const ::mifare::plus::counter::get::GetCounter& get_counter() const;
  ::mifare::plus::counter::get::GetCounter* release_get_counter();
  ::mifare::plus::counter::get::GetCounter* mutable_get_counter();
  void set_allocated_get_counter(::mifare::plus::counter::get::GetCounter* get_counter);
  private:
  const ::mifare::plus::counter::get::GetCounter& _internal_get_counter() const;
  ::mifare::plus::counter::get::GetCounter* _internal_mutable_get_counter();
  public:

  // optional .mifare.plus.counter.set.SetCounter set_counter = 5;
  bool has_set_counter() const;
  private:
  bool _internal_has_set_counter() const;
  public:
  void clear_set_counter();
  const ::mifare::plus::counter::set::SetCounter& set_counter() const;
  ::mifare::plus::counter::set::SetCounter* release_set_counter();
  ::mifare::plus::counter::set::SetCounter* mutable_set_counter();
  void set_allocated_set_counter(::mifare::plus::counter::set::SetCounter* set_counter);
  private:
  const ::mifare::plus::counter::set::SetCounter& _internal_set_counter() const;
  ::mifare::plus::counter::set::SetCounter* _internal_mutable_set_counter();
  public:

  // optional .mifare.plus.counter.modify.ModifyCounter modify_counter = 6;
  bool has_modify_counter() const;
  private:
  bool _internal_has_modify_counter() const;
  public:
  void clear_modify_counter();
  const ::mifare::plus::counter::modify::ModifyCounter& modify_counter() const;
  ::mifare::plus::counter::modify::ModifyCounter* release_modify_counter();
  ::mifare::plus::counter::modify::ModifyCounter* mutable_modify_counter();
  void set_allocated_modify_counter(::mifare::plus::counter::modify::ModifyCounter* modify_counter);
  private:
  const ::mifare::plus::counter::modify::ModifyCounter& _internal_modify_counter() const;
  ::mifare::plus::counter::modify::ModifyCounter* _internal_mutable_modify_counter();
  public:

  // optional .mifare.plus.counter.copy.CopyCounter copy_counter = 7;
  bool has_copy_counter() const;
  private:
  bool _internal_has_copy_counter() const;
  public:
  void clear_copy_counter();
  const ::mifare::plus::counter::copy::CopyCounter& copy_counter() const;
  ::mifare::plus::counter::copy::CopyCounter* release_copy_counter();
  ::mifare::plus::counter::copy::CopyCounter* mutable_copy_counter();
  void set_allocated_copy_counter(::mifare::plus::counter::copy::CopyCounter* copy_counter);
  private:
  const ::mifare::plus::counter::copy::CopyCounter& _internal_copy_counter() const;
  ::mifare::plus::counter::copy::CopyCounter* _internal_mutable_copy_counter();
  public:

  // optional .mifare.plus.counter.commit.CommitCounter commit_counter = 8;
  bool has_commit_counter() const;
  private:
  bool _internal_has_commit_counter() const;
  public:
  void clear_commit_counter();
  const ::mifare::plus::counter::commit::CommitCounter& commit_counter() const;
  ::mifare::plus::counter::commit::CommitCounter* release_commit_counter();
  ::mifare::plus::counter::commit::CommitCounter* mutable_commit_counter();
  void set_allocated_commit_counter(::mifare::plus::counter::commit::CommitCounter* commit_counter);
  private:
  const ::mifare::plus::counter::commit::CommitCounter& _internal_commit_counter() const;
  ::mifare::plus::counter::commit::CommitCounter* _internal_mutable_commit_counter();
  public:

  // optional .mifare.plus.auth.SamKey auth_on_sam_key = 9;
  bool has_auth_on_sam_key() const;
  private:
  bool _internal_has_auth_on_sam_key() const;
  public:
  void clear_auth_on_sam_key();
  const ::mifare::plus::auth::SamKey& auth_on_sam_key() const;
  ::mifare::plus::auth::SamKey* release_auth_on_sam_key();
  ::mifare::plus::auth::SamKey* mutable_auth_on_sam_key();
  void set_allocated_auth_on_sam_key(::mifare::plus::auth::SamKey* auth_on_sam_key);
  private:
  const ::mifare::plus::auth::SamKey& _internal_auth_on_sam_key() const;
  ::mifare::plus::auth::SamKey* _internal_mutable_auth_on_sam_key();
  public:

  void clear_MfrCmd();
  MfrCmdCase MfrCmd_case() const;
  // @@protoc_insertion_point(class_scope:mifare.plus.bulk.Command)
 private:
  class _Internal;
  void set_has_auth_on_clear_key();
  void set_has_read_blocks();
  void set_has_write_blocks();
  void set_has_get_counter();
  void set_has_set_counter();
  void set_has_modify_counter();
  void set_has_copy_counter();
  void set_has_commit_counter();
  void set_has_auth_on_sam_key();

  inline bool has_MfrCmd() const;
  inline void clear_has_MfrCmd();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  union MfrCmdUnion {
    MfrCmdUnion() {}
    ::mifare::plus::auth::ClearKey* auth_on_clear_key_;
    ::mifare::plus::read::ReadBlocks* read_blocks_;
    ::mifare::plus::write::WriteBlocks* write_blocks_;
    ::mifare::plus::counter::get::GetCounter* get_counter_;
    ::mifare::plus::counter::set::SetCounter* set_counter_;
    ::mifare::plus::counter::modify::ModifyCounter* modify_counter_;
    ::mifare::plus::counter::copy::CopyCounter* copy_counter_;
    ::mifare::plus::counter::commit::CommitCounter* commit_counter_;
    ::mifare::plus::auth::SamKey* auth_on_sam_key_;
  } MfrCmd_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_mifare_2fplus_2fbulk_2eproto;
};
// -------------------------------------------------------------------

class CommandResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mifare.plus.bulk.CommandResult) */ {
 public:
  CommandResult();
  virtual ~CommandResult();

  CommandResult(const CommandResult& from);
  CommandResult(CommandResult&& from) noexcept
    : CommandResult() {
    *this = ::std::move(from);
  }

  inline CommandResult& operator=(const CommandResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandResult& operator=(CommandResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandResult& default_instance();

  enum MfrResultCase {
    kReadBlocks = 1,
    kGetCounter = 2,
    MFRRESULT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandResult* internal_default_instance() {
    return reinterpret_cast<const CommandResult*>(
               &_CommandResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CommandResult& a, CommandResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandResult* New() const final {
    return CreateMaybeMessage<CommandResult>(nullptr);
  }

  CommandResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandResult& from);
  void MergeFrom(const CommandResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mifare.plus.bulk.CommandResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mifare_2fplus_2fbulk_2eproto);
    return ::descriptor_table_mifare_2fplus_2fbulk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadBlocksFieldNumber = 1,
    kGetCounterFieldNumber = 2,
  };
  // optional .mifare.plus.read.Blocks read_blocks = 1;
  bool has_read_blocks() const;
  private:
  bool _internal_has_read_blocks() const;
  public:
  void clear_read_blocks();
  const ::mifare::plus::read::Blocks& read_blocks() const;
  ::mifare::plus::read::Blocks* release_read_blocks();
  ::mifare::plus::read::Blocks* mutable_read_blocks();
  void set_allocated_read_blocks(::mifare::plus::read::Blocks* read_blocks);
  private:
  const ::mifare::plus::read::Blocks& _internal_read_blocks() const;
  ::mifare::plus::read::Blocks* _internal_mutable_read_blocks();
  public:

  // optional .mifare.plus.counter.get.Counter get_counter = 2;
  bool has_get_counter() const;
  private:
  bool _internal_has_get_counter() const;
  public:
  void clear_get_counter();
  const ::mifare::plus::counter::get::Counter& get_counter() const;
  ::mifare::plus::counter::get::Counter* release_get_counter();
  ::mifare::plus::counter::get::Counter* mutable_get_counter();
  void set_allocated_get_counter(::mifare::plus::counter::get::Counter* get_counter);
  private:
  const ::mifare::plus::counter::get::Counter& _internal_get_counter() const;
  ::mifare::plus::counter::get::Counter* _internal_mutable_get_counter();
  public:

  void clear_MfrResult();
  MfrResultCase MfrResult_case() const;
  // @@protoc_insertion_point(class_scope:mifare.plus.bulk.CommandResult)
 private:
  class _Internal;
  void set_has_read_blocks();
  void set_has_get_counter();

  inline bool has_MfrResult() const;
  inline void clear_has_MfrResult();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  union MfrResultUnion {
    MfrResultUnion() {}
    ::mifare::plus::read::Blocks* read_blocks_;
    ::mifare::plus::counter::get::Counter* get_counter_;
  } MfrResult_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_mifare_2fplus_2fbulk_2eproto;
};
// -------------------------------------------------------------------

class BulkOperation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mifare.plus.bulk.BulkOperation) */ {
 public:
  BulkOperation();
  virtual ~BulkOperation();

  BulkOperation(const BulkOperation& from);
  BulkOperation(BulkOperation&& from) noexcept
    : BulkOperation() {
    *this = ::std::move(from);
  }

  inline BulkOperation& operator=(const BulkOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkOperation& operator=(BulkOperation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BulkOperation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BulkOperation* internal_default_instance() {
    return reinterpret_cast<const BulkOperation*>(
               &_BulkOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BulkOperation& a, BulkOperation& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkOperation* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BulkOperation* New() const final {
    return CreateMaybeMessage<BulkOperation>(nullptr);
  }

  BulkOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BulkOperation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BulkOperation& from);
  void MergeFrom(const BulkOperation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkOperation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mifare.plus.bulk.BulkOperation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mifare_2fplus_2fbulk_2eproto);
    return ::descriptor_table_mifare_2fplus_2fbulk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationsFieldNumber = 1,
  };
  // repeated .mifare.plus.bulk.Command operations = 1;
  int operations_size() const;
  private:
  int _internal_operations_size() const;
  public:
  void clear_operations();
  ::mifare::plus::bulk::Command* mutable_operations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::plus::bulk::Command >*
      mutable_operations();
  private:
  const ::mifare::plus::bulk::Command& _internal_operations(int index) const;
  ::mifare::plus::bulk::Command* _internal_add_operations();
  public:
  const ::mifare::plus::bulk::Command& operations(int index) const;
  ::mifare::plus::bulk::Command* add_operations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::plus::bulk::Command >&
      operations() const;

  // @@protoc_insertion_point(class_scope:mifare.plus.bulk.BulkOperation)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::plus::bulk::Command > operations_;
  friend struct ::TableStruct_mifare_2fplus_2fbulk_2eproto;
};
// -------------------------------------------------------------------

class BulkResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mifare.plus.bulk.BulkResult) */ {
 public:
  BulkResult();
  virtual ~BulkResult();

  BulkResult(const BulkResult& from);
  BulkResult(BulkResult&& from) noexcept
    : BulkResult() {
    *this = ::std::move(from);
  }

  inline BulkResult& operator=(const BulkResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkResult& operator=(BulkResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BulkResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BulkResult* internal_default_instance() {
    return reinterpret_cast<const BulkResult*>(
               &_BulkResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BulkResult& a, BulkResult& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BulkResult* New() const final {
    return CreateMaybeMessage<BulkResult>(nullptr);
  }

  BulkResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BulkResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BulkResult& from);
  void MergeFrom(const BulkResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mifare.plus.bulk.BulkResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mifare_2fplus_2fbulk_2eproto);
    return ::descriptor_table_mifare_2fplus_2fbulk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .mifare.plus.bulk.CommandResult results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::mifare::plus::bulk::CommandResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::plus::bulk::CommandResult >*
      mutable_results();
  private:
  const ::mifare::plus::bulk::CommandResult& _internal_results(int index) const;
  ::mifare::plus::bulk::CommandResult* _internal_add_results();
  public:
  const ::mifare::plus::bulk::CommandResult& results(int index) const;
  ::mifare::plus::bulk::CommandResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::plus::bulk::CommandResult >&
      results() const;

  // @@protoc_insertion_point(class_scope:mifare.plus.bulk.BulkResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::plus::bulk::CommandResult > results_;
  friend struct ::TableStruct_mifare_2fplus_2fbulk_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Command

// optional .mifare.plus.auth.ClearKey auth_on_clear_key = 1;
inline bool Command::_internal_has_auth_on_clear_key() const {
  return MfrCmd_case() == kAuthOnClearKey;
}
inline bool Command::has_auth_on_clear_key() const {
  return _internal_has_auth_on_clear_key();
}
inline void Command::set_has_auth_on_clear_key() {
  _oneof_case_[0] = kAuthOnClearKey;
}
inline ::mifare::plus::auth::ClearKey* Command::release_auth_on_clear_key() {
  // @@protoc_insertion_point(field_release:mifare.plus.bulk.Command.auth_on_clear_key)
  if (_internal_has_auth_on_clear_key()) {
    clear_has_MfrCmd();
      ::mifare::plus::auth::ClearKey* temp = MfrCmd_.auth_on_clear_key_;
    MfrCmd_.auth_on_clear_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::plus::auth::ClearKey& Command::_internal_auth_on_clear_key() const {
  return _internal_has_auth_on_clear_key()
      ? *MfrCmd_.auth_on_clear_key_
      : *reinterpret_cast< ::mifare::plus::auth::ClearKey*>(&::mifare::plus::auth::_ClearKey_default_instance_);
}
inline const ::mifare::plus::auth::ClearKey& Command::auth_on_clear_key() const {
  // @@protoc_insertion_point(field_get:mifare.plus.bulk.Command.auth_on_clear_key)
  return _internal_auth_on_clear_key();
}
inline ::mifare::plus::auth::ClearKey* Command::_internal_mutable_auth_on_clear_key() {
  if (!_internal_has_auth_on_clear_key()) {
    clear_MfrCmd();
    set_has_auth_on_clear_key();
    MfrCmd_.auth_on_clear_key_ = CreateMaybeMessage< ::mifare::plus::auth::ClearKey >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.auth_on_clear_key_;
}
inline ::mifare::plus::auth::ClearKey* Command::mutable_auth_on_clear_key() {
  // @@protoc_insertion_point(field_mutable:mifare.plus.bulk.Command.auth_on_clear_key)
  return _internal_mutable_auth_on_clear_key();
}

// optional .mifare.plus.read.ReadBlocks read_blocks = 2;
inline bool Command::_internal_has_read_blocks() const {
  return MfrCmd_case() == kReadBlocks;
}
inline bool Command::has_read_blocks() const {
  return _internal_has_read_blocks();
}
inline void Command::set_has_read_blocks() {
  _oneof_case_[0] = kReadBlocks;
}
inline ::mifare::plus::read::ReadBlocks* Command::release_read_blocks() {
  // @@protoc_insertion_point(field_release:mifare.plus.bulk.Command.read_blocks)
  if (_internal_has_read_blocks()) {
    clear_has_MfrCmd();
      ::mifare::plus::read::ReadBlocks* temp = MfrCmd_.read_blocks_;
    MfrCmd_.read_blocks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::plus::read::ReadBlocks& Command::_internal_read_blocks() const {
  return _internal_has_read_blocks()
      ? *MfrCmd_.read_blocks_
      : *reinterpret_cast< ::mifare::plus::read::ReadBlocks*>(&::mifare::plus::read::_ReadBlocks_default_instance_);
}
inline const ::mifare::plus::read::ReadBlocks& Command::read_blocks() const {
  // @@protoc_insertion_point(field_get:mifare.plus.bulk.Command.read_blocks)
  return _internal_read_blocks();
}
inline ::mifare::plus::read::ReadBlocks* Command::_internal_mutable_read_blocks() {
  if (!_internal_has_read_blocks()) {
    clear_MfrCmd();
    set_has_read_blocks();
    MfrCmd_.read_blocks_ = CreateMaybeMessage< ::mifare::plus::read::ReadBlocks >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.read_blocks_;
}
inline ::mifare::plus::read::ReadBlocks* Command::mutable_read_blocks() {
  // @@protoc_insertion_point(field_mutable:mifare.plus.bulk.Command.read_blocks)
  return _internal_mutable_read_blocks();
}

// optional .mifare.plus.write.WriteBlocks write_blocks = 3;
inline bool Command::_internal_has_write_blocks() const {
  return MfrCmd_case() == kWriteBlocks;
}
inline bool Command::has_write_blocks() const {
  return _internal_has_write_blocks();
}
inline void Command::set_has_write_blocks() {
  _oneof_case_[0] = kWriteBlocks;
}
inline ::mifare::plus::write::WriteBlocks* Command::release_write_blocks() {
  // @@protoc_insertion_point(field_release:mifare.plus.bulk.Command.write_blocks)
  if (_internal_has_write_blocks()) {
    clear_has_MfrCmd();
      ::mifare::plus::write::WriteBlocks* temp = MfrCmd_.write_blocks_;
    MfrCmd_.write_blocks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::plus::write::WriteBlocks& Command::_internal_write_blocks() const {
  return _internal_has_write_blocks()
      ? *MfrCmd_.write_blocks_
      : *reinterpret_cast< ::mifare::plus::write::WriteBlocks*>(&::mifare::plus::write::_WriteBlocks_default_instance_);
}
inline const ::mifare::plus::write::WriteBlocks& Command::write_blocks() const {
  // @@protoc_insertion_point(field_get:mifare.plus.bulk.Command.write_blocks)
  return _internal_write_blocks();
}
inline ::mifare::plus::write::WriteBlocks* Command::_internal_mutable_write_blocks() {
  if (!_internal_has_write_blocks()) {
    clear_MfrCmd();
    set_has_write_blocks();
    MfrCmd_.write_blocks_ = CreateMaybeMessage< ::mifare::plus::write::WriteBlocks >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.write_blocks_;
}
inline ::mifare::plus::write::WriteBlocks* Command::mutable_write_blocks() {
  // @@protoc_insertion_point(field_mutable:mifare.plus.bulk.Command.write_blocks)
  return _internal_mutable_write_blocks();
}

// optional .mifare.plus.counter.get.GetCounter get_counter = 4;
inline bool Command::_internal_has_get_counter() const {
  return MfrCmd_case() == kGetCounter;
}
inline bool Command::has_get_counter() const {
  return _internal_has_get_counter();
}
inline void Command::set_has_get_counter() {
  _oneof_case_[0] = kGetCounter;
}
inline ::mifare::plus::counter::get::GetCounter* Command::release_get_counter() {
  // @@protoc_insertion_point(field_release:mifare.plus.bulk.Command.get_counter)
  if (_internal_has_get_counter()) {
    clear_has_MfrCmd();
      ::mifare::plus::counter::get::GetCounter* temp = MfrCmd_.get_counter_;
    MfrCmd_.get_counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::plus::counter::get::GetCounter& Command::_internal_get_counter() const {
  return _internal_has_get_counter()
      ? *MfrCmd_.get_counter_
      : *reinterpret_cast< ::mifare::plus::counter::get::GetCounter*>(&::mifare::plus::counter::get::_GetCounter_default_instance_);
}
inline const ::mifare::plus::counter::get::GetCounter& Command::get_counter() const {
  // @@protoc_insertion_point(field_get:mifare.plus.bulk.Command.get_counter)
  return _internal_get_counter();
}
inline ::mifare::plus::counter::get::GetCounter* Command::_internal_mutable_get_counter() {
  if (!_internal_has_get_counter()) {
    clear_MfrCmd();
    set_has_get_counter();
    MfrCmd_.get_counter_ = CreateMaybeMessage< ::mifare::plus::counter::get::GetCounter >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.get_counter_;
}
inline ::mifare::plus::counter::get::GetCounter* Command::mutable_get_counter() {
  // @@protoc_insertion_point(field_mutable:mifare.plus.bulk.Command.get_counter)
  return _internal_mutable_get_counter();
}

// optional .mifare.plus.counter.set.SetCounter set_counter = 5;
inline bool Command::_internal_has_set_counter() const {
  return MfrCmd_case() == kSetCounter;
}
inline bool Command::has_set_counter() const {
  return _internal_has_set_counter();
}
inline void Command::set_has_set_counter() {
  _oneof_case_[0] = kSetCounter;
}
inline ::mifare::plus::counter::set::SetCounter* Command::release_set_counter() {
  // @@protoc_insertion_point(field_release:mifare.plus.bulk.Command.set_counter)
  if (_internal_has_set_counter()) {
    clear_has_MfrCmd();
      ::mifare::plus::counter::set::SetCounter* temp = MfrCmd_.set_counter_;
    MfrCmd_.set_counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::plus::counter::set::SetCounter& Command::_internal_set_counter() const {
  return _internal_has_set_counter()
      ? *MfrCmd_.set_counter_
      : *reinterpret_cast< ::mifare::plus::counter::set::SetCounter*>(&::mifare::plus::counter::set::_SetCounter_default_instance_);
}
inline const ::mifare::plus::counter::set::SetCounter& Command::set_counter() const {
  // @@protoc_insertion_point(field_get:mifare.plus.bulk.Command.set_counter)
  return _internal_set_counter();
}
inline ::mifare::plus::counter::set::SetCounter* Command::_internal_mutable_set_counter() {
  if (!_internal_has_set_counter()) {
    clear_MfrCmd();
    set_has_set_counter();
    MfrCmd_.set_counter_ = CreateMaybeMessage< ::mifare::plus::counter::set::SetCounter >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.set_counter_;
}
inline ::mifare::plus::counter::set::SetCounter* Command::mutable_set_counter() {
  // @@protoc_insertion_point(field_mutable:mifare.plus.bulk.Command.set_counter)
  return _internal_mutable_set_counter();
}

// optional .mifare.plus.counter.modify.ModifyCounter modify_counter = 6;
inline bool Command::_internal_has_modify_counter() const {
  return MfrCmd_case() == kModifyCounter;
}
inline bool Command::has_modify_counter() const {
  return _internal_has_modify_counter();
}
inline void Command::set_has_modify_counter() {
  _oneof_case_[0] = kModifyCounter;
}
inline ::mifare::plus::counter::modify::ModifyCounter* Command::release_modify_counter() {
  // @@protoc_insertion_point(field_release:mifare.plus.bulk.Command.modify_counter)
  if (_internal_has_modify_counter()) {
    clear_has_MfrCmd();
      ::mifare::plus::counter::modify::ModifyCounter* temp = MfrCmd_.modify_counter_;
    MfrCmd_.modify_counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::plus::counter::modify::ModifyCounter& Command::_internal_modify_counter() const {
  return _internal_has_modify_counter()
      ? *MfrCmd_.modify_counter_
      : *reinterpret_cast< ::mifare::plus::counter::modify::ModifyCounter*>(&::mifare::plus::counter::modify::_ModifyCounter_default_instance_);
}
inline const ::mifare::plus::counter::modify::ModifyCounter& Command::modify_counter() const {
  // @@protoc_insertion_point(field_get:mifare.plus.bulk.Command.modify_counter)
  return _internal_modify_counter();
}
inline ::mifare::plus::counter::modify::ModifyCounter* Command::_internal_mutable_modify_counter() {
  if (!_internal_has_modify_counter()) {
    clear_MfrCmd();
    set_has_modify_counter();
    MfrCmd_.modify_counter_ = CreateMaybeMessage< ::mifare::plus::counter::modify::ModifyCounter >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.modify_counter_;
}
inline ::mifare::plus::counter::modify::ModifyCounter* Command::mutable_modify_counter() {
  // @@protoc_insertion_point(field_mutable:mifare.plus.bulk.Command.modify_counter)
  return _internal_mutable_modify_counter();
}

// optional .mifare.plus.counter.copy.CopyCounter copy_counter = 7;
inline bool Command::_internal_has_copy_counter() const {
  return MfrCmd_case() == kCopyCounter;
}
inline bool Command::has_copy_counter() const {
  return _internal_has_copy_counter();
}
inline void Command::set_has_copy_counter() {
  _oneof_case_[0] = kCopyCounter;
}
inline ::mifare::plus::counter::copy::CopyCounter* Command::release_copy_counter() {
  // @@protoc_insertion_point(field_release:mifare.plus.bulk.Command.copy_counter)
  if (_internal_has_copy_counter()) {
    clear_has_MfrCmd();
      ::mifare::plus::counter::copy::CopyCounter* temp = MfrCmd_.copy_counter_;
    MfrCmd_.copy_counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::plus::counter::copy::CopyCounter& Command::_internal_copy_counter() const {
  return _internal_has_copy_counter()
      ? *MfrCmd_.copy_counter_
      : *reinterpret_cast< ::mifare::plus::counter::copy::CopyCounter*>(&::mifare::plus::counter::copy::_CopyCounter_default_instance_);
}
inline const ::mifare::plus::counter::copy::CopyCounter& Command::copy_counter() const {
  // @@protoc_insertion_point(field_get:mifare.plus.bulk.Command.copy_counter)
  return _internal_copy_counter();
}
inline ::mifare::plus::counter::copy::CopyCounter* Command::_internal_mutable_copy_counter() {
  if (!_internal_has_copy_counter()) {
    clear_MfrCmd();
    set_has_copy_counter();
    MfrCmd_.copy_counter_ = CreateMaybeMessage< ::mifare::plus::counter::copy::CopyCounter >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.copy_counter_;
}
inline ::mifare::plus::counter::copy::CopyCounter* Command::mutable_copy_counter() {
  // @@protoc_insertion_point(field_mutable:mifare.plus.bulk.Command.copy_counter)
  return _internal_mutable_copy_counter();
}

// optional .mifare.plus.counter.commit.CommitCounter commit_counter = 8;
inline bool Command::_internal_has_commit_counter() const {
  return MfrCmd_case() == kCommitCounter;
}
inline bool Command::has_commit_counter() const {
  return _internal_has_commit_counter();
}
inline void Command::set_has_commit_counter() {
  _oneof_case_[0] = kCommitCounter;
}
inline ::mifare::plus::counter::commit::CommitCounter* Command::release_commit_counter() {
  // @@protoc_insertion_point(field_release:mifare.plus.bulk.Command.commit_counter)
  if (_internal_has_commit_counter()) {
    clear_has_MfrCmd();
      ::mifare::plus::counter::commit::CommitCounter* temp = MfrCmd_.commit_counter_;
    MfrCmd_.commit_counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::plus::counter::commit::CommitCounter& Command::_internal_commit_counter() const {
  return _internal_has_commit_counter()
      ? *MfrCmd_.commit_counter_
      : *reinterpret_cast< ::mifare::plus::counter::commit::CommitCounter*>(&::mifare::plus::counter::commit::_CommitCounter_default_instance_);
}
inline const ::mifare::plus::counter::commit::CommitCounter& Command::commit_counter() const {
  // @@protoc_insertion_point(field_get:mifare.plus.bulk.Command.commit_counter)
  return _internal_commit_counter();
}
inline ::mifare::plus::counter::commit::CommitCounter* Command::_internal_mutable_commit_counter() {
  if (!_internal_has_commit_counter()) {
    clear_MfrCmd();
    set_has_commit_counter();
    MfrCmd_.commit_counter_ = CreateMaybeMessage< ::mifare::plus::counter::commit::CommitCounter >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.commit_counter_;
}
inline ::mifare::plus::counter::commit::CommitCounter* Command::mutable_commit_counter() {
  // @@protoc_insertion_point(field_mutable:mifare.plus.bulk.Command.commit_counter)
  return _internal_mutable_commit_counter();
}

// optional .mifare.plus.auth.SamKey auth_on_sam_key = 9;
inline bool Command::_internal_has_auth_on_sam_key() const {
  return MfrCmd_case() == kAuthOnSamKey;
}
inline bool Command::has_auth_on_sam_key() const {
  return _internal_has_auth_on_sam_key();
}
inline void Command::set_has_auth_on_sam_key() {
  _oneof_case_[0] = kAuthOnSamKey;
}
inline ::mifare::plus::auth::SamKey* Command::release_auth_on_sam_key() {
  // @@protoc_insertion_point(field_release:mifare.plus.bulk.Command.auth_on_sam_key)
  if (_internal_has_auth_on_sam_key()) {
    clear_has_MfrCmd();
      ::mifare::plus::auth::SamKey* temp = MfrCmd_.auth_on_sam_key_;
    MfrCmd_.auth_on_sam_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::plus::auth::SamKey& Command::_internal_auth_on_sam_key() const {
  return _internal_has_auth_on_sam_key()
      ? *MfrCmd_.auth_on_sam_key_
      : *reinterpret_cast< ::mifare::plus::auth::SamKey*>(&::mifare::plus::auth::_SamKey_default_instance_);
}
inline const ::mifare::plus::auth::SamKey& Command::auth_on_sam_key() const {
  // @@protoc_insertion_point(field_get:mifare.plus.bulk.Command.auth_on_sam_key)
  return _internal_auth_on_sam_key();
}
inline ::mifare::plus::auth::SamKey* Command::_internal_mutable_auth_on_sam_key() {
  if (!_internal_has_auth_on_sam_key()) {
    clear_MfrCmd();
    set_has_auth_on_sam_key();
    MfrCmd_.auth_on_sam_key_ = CreateMaybeMessage< ::mifare::plus::auth::SamKey >(
        GetArenaNoVirtual());
  }
  return MfrCmd_.auth_on_sam_key_;
}
inline ::mifare::plus::auth::SamKey* Command::mutable_auth_on_sam_key() {
  // @@protoc_insertion_point(field_mutable:mifare.plus.bulk.Command.auth_on_sam_key)
  return _internal_mutable_auth_on_sam_key();
}

inline bool Command::has_MfrCmd() const {
  return MfrCmd_case() != MFRCMD_NOT_SET;
}
inline void Command::clear_has_MfrCmd() {
  _oneof_case_[0] = MFRCMD_NOT_SET;
}
inline Command::MfrCmdCase Command::MfrCmd_case() const {
  return Command::MfrCmdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CommandResult

// optional .mifare.plus.read.Blocks read_blocks = 1;
inline bool CommandResult::_internal_has_read_blocks() const {
  return MfrResult_case() == kReadBlocks;
}
inline bool CommandResult::has_read_blocks() const {
  return _internal_has_read_blocks();
}
inline void CommandResult::set_has_read_blocks() {
  _oneof_case_[0] = kReadBlocks;
}
inline ::mifare::plus::read::Blocks* CommandResult::release_read_blocks() {
  // @@protoc_insertion_point(field_release:mifare.plus.bulk.CommandResult.read_blocks)
  if (_internal_has_read_blocks()) {
    clear_has_MfrResult();
      ::mifare::plus::read::Blocks* temp = MfrResult_.read_blocks_;
    MfrResult_.read_blocks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::plus::read::Blocks& CommandResult::_internal_read_blocks() const {
  return _internal_has_read_blocks()
      ? *MfrResult_.read_blocks_
      : *reinterpret_cast< ::mifare::plus::read::Blocks*>(&::mifare::plus::read::_Blocks_default_instance_);
}
inline const ::mifare::plus::read::Blocks& CommandResult::read_blocks() const {
  // @@protoc_insertion_point(field_get:mifare.plus.bulk.CommandResult.read_blocks)
  return _internal_read_blocks();
}
inline ::mifare::plus::read::Blocks* CommandResult::_internal_mutable_read_blocks() {
  if (!_internal_has_read_blocks()) {
    clear_MfrResult();
    set_has_read_blocks();
    MfrResult_.read_blocks_ = CreateMaybeMessage< ::mifare::plus::read::Blocks >(
        GetArenaNoVirtual());
  }
  return MfrResult_.read_blocks_;
}
inline ::mifare::plus::read::Blocks* CommandResult::mutable_read_blocks() {
  // @@protoc_insertion_point(field_mutable:mifare.plus.bulk.CommandResult.read_blocks)
  return _internal_mutable_read_blocks();
}

// optional .mifare.plus.counter.get.Counter get_counter = 2;
inline bool CommandResult::_internal_has_get_counter() const {
  return MfrResult_case() == kGetCounter;
}
inline bool CommandResult::has_get_counter() const {
  return _internal_has_get_counter();
}
inline void CommandResult::set_has_get_counter() {
  _oneof_case_[0] = kGetCounter;
}
inline ::mifare::plus::counter::get::Counter* CommandResult::release_get_counter() {
  // @@protoc_insertion_point(field_release:mifare.plus.bulk.CommandResult.get_counter)
  if (_internal_has_get_counter()) {
    clear_has_MfrResult();
      ::mifare::plus::counter::get::Counter* temp = MfrResult_.get_counter_;
    MfrResult_.get_counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mifare::plus::counter::get::Counter& CommandResult::_internal_get_counter() const {
  return _internal_has_get_counter()
      ? *MfrResult_.get_counter_
      : *reinterpret_cast< ::mifare::plus::counter::get::Counter*>(&::mifare::plus::counter::get::_Counter_default_instance_);
}
inline const ::mifare::plus::counter::get::Counter& CommandResult::get_counter() const {
  // @@protoc_insertion_point(field_get:mifare.plus.bulk.CommandResult.get_counter)
  return _internal_get_counter();
}
inline ::mifare::plus::counter::get::Counter* CommandResult::_internal_mutable_get_counter() {
  if (!_internal_has_get_counter()) {
    clear_MfrResult();
    set_has_get_counter();
    MfrResult_.get_counter_ = CreateMaybeMessage< ::mifare::plus::counter::get::Counter >(
        GetArenaNoVirtual());
  }
  return MfrResult_.get_counter_;
}
inline ::mifare::plus::counter::get::Counter* CommandResult::mutable_get_counter() {
  // @@protoc_insertion_point(field_mutable:mifare.plus.bulk.CommandResult.get_counter)
  return _internal_mutable_get_counter();
}

inline bool CommandResult::has_MfrResult() const {
  return MfrResult_case() != MFRRESULT_NOT_SET;
}
inline void CommandResult::clear_has_MfrResult() {
  _oneof_case_[0] = MFRRESULT_NOT_SET;
}
inline CommandResult::MfrResultCase CommandResult::MfrResult_case() const {
  return CommandResult::MfrResultCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BulkOperation

// repeated .mifare.plus.bulk.Command operations = 1;
inline int BulkOperation::_internal_operations_size() const {
  return operations_.size();
}
inline int BulkOperation::operations_size() const {
  return _internal_operations_size();
}
inline void BulkOperation::clear_operations() {
  operations_.Clear();
}
inline ::mifare::plus::bulk::Command* BulkOperation::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:mifare.plus.bulk.BulkOperation.operations)
  return operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::plus::bulk::Command >*
BulkOperation::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:mifare.plus.bulk.BulkOperation.operations)
  return &operations_;
}
inline const ::mifare::plus::bulk::Command& BulkOperation::_internal_operations(int index) const {
  return operations_.Get(index);
}
inline const ::mifare::plus::bulk::Command& BulkOperation::operations(int index) const {
  // @@protoc_insertion_point(field_get:mifare.plus.bulk.BulkOperation.operations)
  return _internal_operations(index);
}
inline ::mifare::plus::bulk::Command* BulkOperation::_internal_add_operations() {
  return operations_.Add();
}
inline ::mifare::plus::bulk::Command* BulkOperation::add_operations() {
  // @@protoc_insertion_point(field_add:mifare.plus.bulk.BulkOperation.operations)
  return _internal_add_operations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::plus::bulk::Command >&
BulkOperation::operations() const {
  // @@protoc_insertion_point(field_list:mifare.plus.bulk.BulkOperation.operations)
  return operations_;
}

// -------------------------------------------------------------------

// BulkResult

// repeated .mifare.plus.bulk.CommandResult results = 1;
inline int BulkResult::_internal_results_size() const {
  return results_.size();
}
inline int BulkResult::results_size() const {
  return _internal_results_size();
}
inline void BulkResult::clear_results() {
  results_.Clear();
}
inline ::mifare::plus::bulk::CommandResult* BulkResult::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:mifare.plus.bulk.BulkResult.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::plus::bulk::CommandResult >*
BulkResult::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:mifare.plus.bulk.BulkResult.results)
  return &results_;
}
inline const ::mifare::plus::bulk::CommandResult& BulkResult::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::mifare::plus::bulk::CommandResult& BulkResult::results(int index) const {
  // @@protoc_insertion_point(field_get:mifare.plus.bulk.BulkResult.results)
  return _internal_results(index);
}
inline ::mifare::plus::bulk::CommandResult* BulkResult::_internal_add_results() {
  return results_.Add();
}
inline ::mifare::plus::bulk::CommandResult* BulkResult::add_results() {
  // @@protoc_insertion_point(field_add:mifare.plus.bulk.BulkResult.results)
  return _internal_add_results();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mifare::plus::bulk::CommandResult >&
BulkResult::results() const {
  // @@protoc_insertion_point(field_list:mifare.plus.bulk.BulkResult.results)
  return results_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bulk
}  // namespace plus
}  // namespace mifare

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mifare_2fplus_2fbulk_2eproto
