// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: misc/device.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_misc_2fdevice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_misc_2fdevice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_misc_2fdevice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_misc_2fdevice_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_misc_2fdevice_2eproto;
namespace misc {
namespace device {
class DeviceInfo;
class DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class DeviceStatus;
class DeviceStatusDefaultTypeInternal;
extern DeviceStatusDefaultTypeInternal _DeviceStatus_default_instance_;
class GetDeviceStatus;
class GetDeviceStatusDefaultTypeInternal;
extern GetDeviceStatusDefaultTypeInternal _GetDeviceStatus_default_instance_;
class ReadDeviceInfo;
class ReadDeviceInfoDefaultTypeInternal;
extern ReadDeviceInfoDefaultTypeInternal _ReadDeviceInfo_default_instance_;
class Security;
class SecurityDefaultTypeInternal;
extern SecurityDefaultTypeInternal _Security_default_instance_;
}  // namespace device
}  // namespace misc
PROTOBUF_NAMESPACE_OPEN
template<> ::misc::device::DeviceInfo* Arena::CreateMaybeMessage<::misc::device::DeviceInfo>(Arena*);
template<> ::misc::device::DeviceStatus* Arena::CreateMaybeMessage<::misc::device::DeviceStatus>(Arena*);
template<> ::misc::device::GetDeviceStatus* Arena::CreateMaybeMessage<::misc::device::GetDeviceStatus>(Arena*);
template<> ::misc::device::ReadDeviceInfo* Arena::CreateMaybeMessage<::misc::device::ReadDeviceInfo>(Arena*);
template<> ::misc::device::Security* Arena::CreateMaybeMessage<::misc::device::Security>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace misc {
namespace device {

enum AntiRemovalProtState : int {
  ACTIVATED = 0,
  DEACTIVATED = 1
};
bool AntiRemovalProtState_IsValid(int value);
constexpr AntiRemovalProtState AntiRemovalProtState_MIN = ACTIVATED;
constexpr AntiRemovalProtState AntiRemovalProtState_MAX = DEACTIVATED;
constexpr int AntiRemovalProtState_ARRAYSIZE = AntiRemovalProtState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AntiRemovalProtState_descriptor();
template<typename T>
inline const std::string& AntiRemovalProtState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AntiRemovalProtState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AntiRemovalProtState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AntiRemovalProtState_descriptor(), enum_t_value);
}
inline bool AntiRemovalProtState_Parse(
    const std::string& name, AntiRemovalProtState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AntiRemovalProtState>(
    AntiRemovalProtState_descriptor(), name, value);
}
// ===================================================================

class ReadDeviceInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:misc.device.ReadDeviceInfo) */ {
 public:
  ReadDeviceInfo();
  virtual ~ReadDeviceInfo();

  ReadDeviceInfo(const ReadDeviceInfo& from);
  ReadDeviceInfo(ReadDeviceInfo&& from) noexcept
    : ReadDeviceInfo() {
    *this = ::std::move(from);
  }

  inline ReadDeviceInfo& operator=(const ReadDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadDeviceInfo& operator=(ReadDeviceInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReadDeviceInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadDeviceInfo* internal_default_instance() {
    return reinterpret_cast<const ReadDeviceInfo*>(
               &_ReadDeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ReadDeviceInfo& a, ReadDeviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadDeviceInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadDeviceInfo* New() const final {
    return CreateMaybeMessage<ReadDeviceInfo>(nullptr);
  }

  ReadDeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadDeviceInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReadDeviceInfo& from);
  void MergeFrom(const ReadDeviceInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadDeviceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "misc.device.ReadDeviceInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_misc_2fdevice_2eproto);
    return ::descriptor_table_misc_2fdevice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:misc.device.ReadDeviceInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_misc_2fdevice_2eproto;
};
// -------------------------------------------------------------------

class DeviceInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:misc.device.DeviceInfo) */ {
 public:
  DeviceInfo();
  virtual ~DeviceInfo();

  DeviceInfo(const DeviceInfo& from);
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeviceInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceInfo* New() const final {
    return CreateMaybeMessage<DeviceInfo>(nullptr);
  }

  DeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "misc.device.DeviceInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_misc_2fdevice_2eproto);
    return ::descriptor_table_misc_2fdevice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerialNumberFieldNumber = 1,
    kIntellireaderVersionFieldNumber = 2,
    kHardwareModelIdFieldNumber = 3,
  };
  // required string serial_number = 1;
  bool has_serial_number() const;
  private:
  bool _internal_has_serial_number() const;
  public:
  void clear_serial_number();
  const std::string& serial_number() const;
  void set_serial_number(const std::string& value);
  void set_serial_number(std::string&& value);
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  std::string* mutable_serial_number();
  std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // required string intellireader_version = 2;
  bool has_intellireader_version() const;
  private:
  bool _internal_has_intellireader_version() const;
  public:
  void clear_intellireader_version();
  const std::string& intellireader_version() const;
  void set_intellireader_version(const std::string& value);
  void set_intellireader_version(std::string&& value);
  void set_intellireader_version(const char* value);
  void set_intellireader_version(const char* value, size_t size);
  std::string* mutable_intellireader_version();
  std::string* release_intellireader_version();
  void set_allocated_intellireader_version(std::string* intellireader_version);
  private:
  const std::string& _internal_intellireader_version() const;
  void _internal_set_intellireader_version(const std::string& value);
  std::string* _internal_mutable_intellireader_version();
  public:

  // optional uint32 hardware_model_id = 3;
  bool has_hardware_model_id() const;
  private:
  bool _internal_has_hardware_model_id() const;
  public:
  void clear_hardware_model_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 hardware_model_id() const;
  void set_hardware_model_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hardware_model_id() const;
  void _internal_set_hardware_model_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:misc.device.DeviceInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr intellireader_version_;
  ::PROTOBUF_NAMESPACE_ID::uint32 hardware_model_id_;
  friend struct ::TableStruct_misc_2fdevice_2eproto;
};
// -------------------------------------------------------------------

class GetDeviceStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:misc.device.GetDeviceStatus) */ {
 public:
  GetDeviceStatus();
  virtual ~GetDeviceStatus();

  GetDeviceStatus(const GetDeviceStatus& from);
  GetDeviceStatus(GetDeviceStatus&& from) noexcept
    : GetDeviceStatus() {
    *this = ::std::move(from);
  }

  inline GetDeviceStatus& operator=(const GetDeviceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDeviceStatus& operator=(GetDeviceStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetDeviceStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetDeviceStatus* internal_default_instance() {
    return reinterpret_cast<const GetDeviceStatus*>(
               &_GetDeviceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetDeviceStatus& a, GetDeviceStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDeviceStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetDeviceStatus* New() const final {
    return CreateMaybeMessage<GetDeviceStatus>(nullptr);
  }

  GetDeviceStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetDeviceStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetDeviceStatus& from);
  void MergeFrom(const GetDeviceStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDeviceStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "misc.device.GetDeviceStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_misc_2fdevice_2eproto);
    return ::descriptor_table_misc_2fdevice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:misc.device.GetDeviceStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_misc_2fdevice_2eproto;
};
// -------------------------------------------------------------------

class DeviceStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:misc.device.DeviceStatus) */ {
 public:
  DeviceStatus();
  virtual ~DeviceStatus();

  DeviceStatus(const DeviceStatus& from);
  DeviceStatus(DeviceStatus&& from) noexcept
    : DeviceStatus() {
    *this = ::std::move(from);
  }

  inline DeviceStatus& operator=(const DeviceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceStatus& operator=(DeviceStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeviceStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceStatus* internal_default_instance() {
    return reinterpret_cast<const DeviceStatus*>(
               &_DeviceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeviceStatus& a, DeviceStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceStatus* New() const final {
    return CreateMaybeMessage<DeviceStatus>(nullptr);
  }

  DeviceStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeviceStatus& from);
  void MergeFrom(const DeviceStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "misc.device.DeviceStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_misc_2fdevice_2eproto);
    return ::descriptor_table_misc_2fdevice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityFieldNumber = 2,
    kTimeLeftToRestartFieldNumber = 1,
  };
  // required .misc.device.Security security = 2;
  bool has_security() const;
  private:
  bool _internal_has_security() const;
  public:
  void clear_security();
  const ::misc::device::Security& security() const;
  ::misc::device::Security* release_security();
  ::misc::device::Security* mutable_security();
  void set_allocated_security(::misc::device::Security* security);
  private:
  const ::misc::device::Security& _internal_security() const;
  ::misc::device::Security* _internal_mutable_security();
  public:

  // required uint32 time_left_to_restart = 1;
  bool has_time_left_to_restart() const;
  private:
  bool _internal_has_time_left_to_restart() const;
  public:
  void clear_time_left_to_restart();
  ::PROTOBUF_NAMESPACE_ID::uint32 time_left_to_restart() const;
  void set_time_left_to_restart(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_time_left_to_restart() const;
  void _internal_set_time_left_to_restart(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:misc.device.DeviceStatus)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::misc::device::Security* security_;
  ::PROTOBUF_NAMESPACE_ID::uint32 time_left_to_restart_;
  friend struct ::TableStruct_misc_2fdevice_2eproto;
};
// -------------------------------------------------------------------

class Security :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:misc.device.Security) */ {
 public:
  Security();
  virtual ~Security();

  Security(const Security& from);
  Security(Security&& from) noexcept
    : Security() {
    *this = ::std::move(from);
  }

  inline Security& operator=(const Security& from) {
    CopyFrom(from);
    return *this;
  }
  inline Security& operator=(Security&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Security& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Security* internal_default_instance() {
    return reinterpret_cast<const Security*>(
               &_Security_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Security& a, Security& b) {
    a.Swap(&b);
  }
  inline void Swap(Security* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Security* New() const final {
    return CreateMaybeMessage<Security>(nullptr);
  }

  Security* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Security>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Security& from);
  void MergeFrom(const Security& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Security* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "misc.device.Security";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_misc_2fdevice_2eproto);
    return ::descriptor_table_misc_2fdevice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRestrictionsReasonFieldNumber = 3,
    kEnabledFieldNumber = 1,
    kPciPtsFunctionsPermittedFieldNumber = 2,
    kAntiRemovalProtectionFieldNumber = 4,
  };
  // optional string restrictions_reason = 3;
  bool has_restrictions_reason() const;
  private:
  bool _internal_has_restrictions_reason() const;
  public:
  void clear_restrictions_reason();
  const std::string& restrictions_reason() const;
  void set_restrictions_reason(const std::string& value);
  void set_restrictions_reason(std::string&& value);
  void set_restrictions_reason(const char* value);
  void set_restrictions_reason(const char* value, size_t size);
  std::string* mutable_restrictions_reason();
  std::string* release_restrictions_reason();
  void set_allocated_restrictions_reason(std::string* restrictions_reason);
  private:
  const std::string& _internal_restrictions_reason() const;
  void _internal_set_restrictions_reason(const std::string& value);
  std::string* _internal_mutable_restrictions_reason();
  public:

  // required bool enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // required bool pci_pts_functions_permitted = 2;
  bool has_pci_pts_functions_permitted() const;
  private:
  bool _internal_has_pci_pts_functions_permitted() const;
  public:
  void clear_pci_pts_functions_permitted();
  bool pci_pts_functions_permitted() const;
  void set_pci_pts_functions_permitted(bool value);
  private:
  bool _internal_pci_pts_functions_permitted() const;
  void _internal_set_pci_pts_functions_permitted(bool value);
  public:

  // optional .misc.device.AntiRemovalProtState anti_removal_protection = 4;
  bool has_anti_removal_protection() const;
  private:
  bool _internal_has_anti_removal_protection() const;
  public:
  void clear_anti_removal_protection();
  ::misc::device::AntiRemovalProtState anti_removal_protection() const;
  void set_anti_removal_protection(::misc::device::AntiRemovalProtState value);
  private:
  ::misc::device::AntiRemovalProtState _internal_anti_removal_protection() const;
  void _internal_set_anti_removal_protection(::misc::device::AntiRemovalProtState value);
  public:

  // @@protoc_insertion_point(class_scope:misc.device.Security)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr restrictions_reason_;
  bool enabled_;
  bool pci_pts_functions_permitted_;
  int anti_removal_protection_;
  friend struct ::TableStruct_misc_2fdevice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReadDeviceInfo

// -------------------------------------------------------------------

// DeviceInfo

// required string serial_number = 1;
inline bool DeviceInfo::_internal_has_serial_number() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceInfo::has_serial_number() const {
  return _internal_has_serial_number();
}
inline void DeviceInfo::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceInfo::serial_number() const {
  // @@protoc_insertion_point(field_get:misc.device.DeviceInfo.serial_number)
  return _internal_serial_number();
}
inline void DeviceInfo::set_serial_number(const std::string& value) {
  _internal_set_serial_number(value);
  // @@protoc_insertion_point(field_set:misc.device.DeviceInfo.serial_number)
}
inline std::string* DeviceInfo::mutable_serial_number() {
  // @@protoc_insertion_point(field_mutable:misc.device.DeviceInfo.serial_number)
  return _internal_mutable_serial_number();
}
inline const std::string& DeviceInfo::_internal_serial_number() const {
  return serial_number_.GetNoArena();
}
inline void DeviceInfo::_internal_set_serial_number(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DeviceInfo::set_serial_number(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  serial_number_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:misc.device.DeviceInfo.serial_number)
}
inline void DeviceInfo::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:misc.device.DeviceInfo.serial_number)
}
inline void DeviceInfo::set_serial_number(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  serial_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:misc.device.DeviceInfo.serial_number)
}
inline std::string* DeviceInfo::_internal_mutable_serial_number() {
  _has_bits_[0] |= 0x00000001u;
  return serial_number_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceInfo::release_serial_number() {
  // @@protoc_insertion_point(field_release:misc.device.DeviceInfo.serial_number)
  if (!_internal_has_serial_number()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return serial_number_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  serial_number_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:misc.device.DeviceInfo.serial_number)
}

// required string intellireader_version = 2;
inline bool DeviceInfo::_internal_has_intellireader_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceInfo::has_intellireader_version() const {
  return _internal_has_intellireader_version();
}
inline void DeviceInfo::clear_intellireader_version() {
  intellireader_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceInfo::intellireader_version() const {
  // @@protoc_insertion_point(field_get:misc.device.DeviceInfo.intellireader_version)
  return _internal_intellireader_version();
}
inline void DeviceInfo::set_intellireader_version(const std::string& value) {
  _internal_set_intellireader_version(value);
  // @@protoc_insertion_point(field_set:misc.device.DeviceInfo.intellireader_version)
}
inline std::string* DeviceInfo::mutable_intellireader_version() {
  // @@protoc_insertion_point(field_mutable:misc.device.DeviceInfo.intellireader_version)
  return _internal_mutable_intellireader_version();
}
inline const std::string& DeviceInfo::_internal_intellireader_version() const {
  return intellireader_version_.GetNoArena();
}
inline void DeviceInfo::_internal_set_intellireader_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  intellireader_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DeviceInfo::set_intellireader_version(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  intellireader_version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:misc.device.DeviceInfo.intellireader_version)
}
inline void DeviceInfo::set_intellireader_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  intellireader_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:misc.device.DeviceInfo.intellireader_version)
}
inline void DeviceInfo::set_intellireader_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  intellireader_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:misc.device.DeviceInfo.intellireader_version)
}
inline std::string* DeviceInfo::_internal_mutable_intellireader_version() {
  _has_bits_[0] |= 0x00000002u;
  return intellireader_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceInfo::release_intellireader_version() {
  // @@protoc_insertion_point(field_release:misc.device.DeviceInfo.intellireader_version)
  if (!_internal_has_intellireader_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return intellireader_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_intellireader_version(std::string* intellireader_version) {
  if (intellireader_version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  intellireader_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), intellireader_version);
  // @@protoc_insertion_point(field_set_allocated:misc.device.DeviceInfo.intellireader_version)
}

// optional uint32 hardware_model_id = 3;
inline bool DeviceInfo::_internal_has_hardware_model_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceInfo::has_hardware_model_id() const {
  return _internal_has_hardware_model_id();
}
inline void DeviceInfo::clear_hardware_model_id() {
  hardware_model_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceInfo::_internal_hardware_model_id() const {
  return hardware_model_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceInfo::hardware_model_id() const {
  // @@protoc_insertion_point(field_get:misc.device.DeviceInfo.hardware_model_id)
  return _internal_hardware_model_id();
}
inline void DeviceInfo::_internal_set_hardware_model_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  hardware_model_id_ = value;
}
inline void DeviceInfo::set_hardware_model_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_hardware_model_id(value);
  // @@protoc_insertion_point(field_set:misc.device.DeviceInfo.hardware_model_id)
}

// -------------------------------------------------------------------

// GetDeviceStatus

// -------------------------------------------------------------------

// DeviceStatus

// required uint32 time_left_to_restart = 1;
inline bool DeviceStatus::_internal_has_time_left_to_restart() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceStatus::has_time_left_to_restart() const {
  return _internal_has_time_left_to_restart();
}
inline void DeviceStatus::clear_time_left_to_restart() {
  time_left_to_restart_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceStatus::_internal_time_left_to_restart() const {
  return time_left_to_restart_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceStatus::time_left_to_restart() const {
  // @@protoc_insertion_point(field_get:misc.device.DeviceStatus.time_left_to_restart)
  return _internal_time_left_to_restart();
}
inline void DeviceStatus::_internal_set_time_left_to_restart(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  time_left_to_restart_ = value;
}
inline void DeviceStatus::set_time_left_to_restart(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_time_left_to_restart(value);
  // @@protoc_insertion_point(field_set:misc.device.DeviceStatus.time_left_to_restart)
}

// required .misc.device.Security security = 2;
inline bool DeviceStatus::_internal_has_security() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || security_ != nullptr);
  return value;
}
inline bool DeviceStatus::has_security() const {
  return _internal_has_security();
}
inline void DeviceStatus::clear_security() {
  if (security_ != nullptr) security_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::misc::device::Security& DeviceStatus::_internal_security() const {
  const ::misc::device::Security* p = security_;
  return p != nullptr ? *p : *reinterpret_cast<const ::misc::device::Security*>(
      &::misc::device::_Security_default_instance_);
}
inline const ::misc::device::Security& DeviceStatus::security() const {
  // @@protoc_insertion_point(field_get:misc.device.DeviceStatus.security)
  return _internal_security();
}
inline ::misc::device::Security* DeviceStatus::release_security() {
  // @@protoc_insertion_point(field_release:misc.device.DeviceStatus.security)
  _has_bits_[0] &= ~0x00000001u;
  ::misc::device::Security* temp = security_;
  security_ = nullptr;
  return temp;
}
inline ::misc::device::Security* DeviceStatus::_internal_mutable_security() {
  _has_bits_[0] |= 0x00000001u;
  if (security_ == nullptr) {
    auto* p = CreateMaybeMessage<::misc::device::Security>(GetArenaNoVirtual());
    security_ = p;
  }
  return security_;
}
inline ::misc::device::Security* DeviceStatus::mutable_security() {
  // @@protoc_insertion_point(field_mutable:misc.device.DeviceStatus.security)
  return _internal_mutable_security();
}
inline void DeviceStatus::set_allocated_security(::misc::device::Security* security) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete security_;
  }
  if (security) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      security = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, security, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  security_ = security;
  // @@protoc_insertion_point(field_set_allocated:misc.device.DeviceStatus.security)
}

// -------------------------------------------------------------------

// Security

// required bool enabled = 1;
inline bool Security::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Security::has_enabled() const {
  return _internal_has_enabled();
}
inline void Security::clear_enabled() {
  enabled_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Security::_internal_enabled() const {
  return enabled_;
}
inline bool Security::enabled() const {
  // @@protoc_insertion_point(field_get:misc.device.Security.enabled)
  return _internal_enabled();
}
inline void Security::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000002u;
  enabled_ = value;
}
inline void Security::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:misc.device.Security.enabled)
}

// required bool pci_pts_functions_permitted = 2;
inline bool Security::_internal_has_pci_pts_functions_permitted() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Security::has_pci_pts_functions_permitted() const {
  return _internal_has_pci_pts_functions_permitted();
}
inline void Security::clear_pci_pts_functions_permitted() {
  pci_pts_functions_permitted_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Security::_internal_pci_pts_functions_permitted() const {
  return pci_pts_functions_permitted_;
}
inline bool Security::pci_pts_functions_permitted() const {
  // @@protoc_insertion_point(field_get:misc.device.Security.pci_pts_functions_permitted)
  return _internal_pci_pts_functions_permitted();
}
inline void Security::_internal_set_pci_pts_functions_permitted(bool value) {
  _has_bits_[0] |= 0x00000004u;
  pci_pts_functions_permitted_ = value;
}
inline void Security::set_pci_pts_functions_permitted(bool value) {
  _internal_set_pci_pts_functions_permitted(value);
  // @@protoc_insertion_point(field_set:misc.device.Security.pci_pts_functions_permitted)
}

// optional string restrictions_reason = 3;
inline bool Security::_internal_has_restrictions_reason() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Security::has_restrictions_reason() const {
  return _internal_has_restrictions_reason();
}
inline void Security::clear_restrictions_reason() {
  restrictions_reason_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Security::restrictions_reason() const {
  // @@protoc_insertion_point(field_get:misc.device.Security.restrictions_reason)
  return _internal_restrictions_reason();
}
inline void Security::set_restrictions_reason(const std::string& value) {
  _internal_set_restrictions_reason(value);
  // @@protoc_insertion_point(field_set:misc.device.Security.restrictions_reason)
}
inline std::string* Security::mutable_restrictions_reason() {
  // @@protoc_insertion_point(field_mutable:misc.device.Security.restrictions_reason)
  return _internal_mutable_restrictions_reason();
}
inline const std::string& Security::_internal_restrictions_reason() const {
  return restrictions_reason_.GetNoArena();
}
inline void Security::_internal_set_restrictions_reason(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  restrictions_reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Security::set_restrictions_reason(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  restrictions_reason_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:misc.device.Security.restrictions_reason)
}
inline void Security::set_restrictions_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  restrictions_reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:misc.device.Security.restrictions_reason)
}
inline void Security::set_restrictions_reason(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  restrictions_reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:misc.device.Security.restrictions_reason)
}
inline std::string* Security::_internal_mutable_restrictions_reason() {
  _has_bits_[0] |= 0x00000001u;
  return restrictions_reason_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Security::release_restrictions_reason() {
  // @@protoc_insertion_point(field_release:misc.device.Security.restrictions_reason)
  if (!_internal_has_restrictions_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return restrictions_reason_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Security::set_allocated_restrictions_reason(std::string* restrictions_reason) {
  if (restrictions_reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  restrictions_reason_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), restrictions_reason);
  // @@protoc_insertion_point(field_set_allocated:misc.device.Security.restrictions_reason)
}

// optional .misc.device.AntiRemovalProtState anti_removal_protection = 4;
inline bool Security::_internal_has_anti_removal_protection() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Security::has_anti_removal_protection() const {
  return _internal_has_anti_removal_protection();
}
inline void Security::clear_anti_removal_protection() {
  anti_removal_protection_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::misc::device::AntiRemovalProtState Security::_internal_anti_removal_protection() const {
  return static_cast< ::misc::device::AntiRemovalProtState >(anti_removal_protection_);
}
inline ::misc::device::AntiRemovalProtState Security::anti_removal_protection() const {
  // @@protoc_insertion_point(field_get:misc.device.Security.anti_removal_protection)
  return _internal_anti_removal_protection();
}
inline void Security::_internal_set_anti_removal_protection(::misc::device::AntiRemovalProtState value) {
  assert(::misc::device::AntiRemovalProtState_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  anti_removal_protection_ = value;
}
inline void Security::set_anti_removal_protection(::misc::device::AntiRemovalProtState value) {
  _internal_set_anti_removal_protection(value);
  // @@protoc_insertion_point(field_set:misc.device.Security.anti_removal_protection)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace device
}  // namespace misc

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::misc::device::AntiRemovalProtState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::misc::device::AntiRemovalProtState>() {
  return ::misc::device::AntiRemovalProtState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_misc_2fdevice_2eproto
