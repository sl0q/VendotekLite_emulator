// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: complex/poll_for_event.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_complex_2fpoll_5ffor_5fevent_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_complex_2fpoll_5ffor_5fevent_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "contactless/poll_for_token.pb.h"
#include "contactless/token.pb.h"
#include "contactless/transaction.pb.h"
#include "gui/screen.pb.h"
#include "misc/leds.pb.h"
#include "qrcode/poll_for_qrcode.pb.h"
#include "qrcode/qrcode_event.pb.h"
#include "touchscreen/poll_touchscreen.pb.h"
#include "touchscreen/touchscreen_event.pb.h"
#include "troika/av3/read_ticket.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_complex_2fpoll_5ffor_5fevent_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_complex_2fpoll_5ffor_5fevent_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_complex_2fpoll_5ffor_5fevent_2eproto;
namespace complex {
namespace poll {
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class MifareCardAction;
class MifareCardActionDefaultTypeInternal;
extern MifareCardActionDefaultTypeInternal _MifareCardAction_default_instance_;
class PollForEvent;
class PollForEventDefaultTypeInternal;
extern PollForEventDefaultTypeInternal _PollForEvent_default_instance_;
class UserInterface;
class UserInterfaceDefaultTypeInternal;
extern UserInterfaceDefaultTypeInternal _UserInterface_default_instance_;
}  // namespace poll
}  // namespace complex
PROTOBUF_NAMESPACE_OPEN
template<> ::complex::poll::Event* Arena::CreateMaybeMessage<::complex::poll::Event>(Arena*);
template<> ::complex::poll::MifareCardAction* Arena::CreateMaybeMessage<::complex::poll::MifareCardAction>(Arena*);
template<> ::complex::poll::PollForEvent* Arena::CreateMaybeMessage<::complex::poll::PollForEvent>(Arena*);
template<> ::complex::poll::UserInterface* Arena::CreateMaybeMessage<::complex::poll::UserInterface>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace complex {
namespace poll {

// ===================================================================

class PollForEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:complex.poll.PollForEvent) */ {
 public:
  PollForEvent();
  virtual ~PollForEvent();

  PollForEvent(const PollForEvent& from);
  PollForEvent(PollForEvent&& from) noexcept
    : PollForEvent() {
    *this = ::std::move(from);
  }

  inline PollForEvent& operator=(const PollForEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PollForEvent& operator=(PollForEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PollForEvent& default_instance();

  enum ContactlessCase {
    kPollForToken = 1,
    kPerformTxn = 2,
    CONTACTLESS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PollForEvent* internal_default_instance() {
    return reinterpret_cast<const PollForEvent*>(
               &_PollForEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PollForEvent& a, PollForEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(PollForEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PollForEvent* New() const final {
    return CreateMaybeMessage<PollForEvent>(nullptr);
  }

  PollForEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PollForEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PollForEvent& from);
  void MergeFrom(const PollForEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PollForEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "complex.poll.PollForEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_complex_2fpoll_5ffor_5fevent_2eproto);
    return ::descriptor_table_complex_2fpoll_5ffor_5fevent_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPollTouchscreenFieldNumber = 3,
    kPollForQrcodeFieldNumber = 4,
    kOnStartUiActionFieldNumber = 5,
    kOnEventUiActionFieldNumber = 6,
    kOnMifareCardPresentFieldNumber = 7,
    kPollForTokenFieldNumber = 1,
    kPerformTxnFieldNumber = 2,
  };
  // optional .touchscreen.poll.PollTouchscreen poll_touchscreen = 3;
  bool has_poll_touchscreen() const;
  private:
  bool _internal_has_poll_touchscreen() const;
  public:
  void clear_poll_touchscreen();
  const ::touchscreen::poll::PollTouchscreen& poll_touchscreen() const;
  ::touchscreen::poll::PollTouchscreen* release_poll_touchscreen();
  ::touchscreen::poll::PollTouchscreen* mutable_poll_touchscreen();
  void set_allocated_poll_touchscreen(::touchscreen::poll::PollTouchscreen* poll_touchscreen);
  private:
  const ::touchscreen::poll::PollTouchscreen& _internal_poll_touchscreen() const;
  ::touchscreen::poll::PollTouchscreen* _internal_mutable_poll_touchscreen();
  public:

  // optional .qrcode.poll.PollForQrCode poll_for_qrcode = 4;
  bool has_poll_for_qrcode() const;
  private:
  bool _internal_has_poll_for_qrcode() const;
  public:
  void clear_poll_for_qrcode();
  const ::qrcode::poll::PollForQrCode& poll_for_qrcode() const;
  ::qrcode::poll::PollForQrCode* release_poll_for_qrcode();
  ::qrcode::poll::PollForQrCode* mutable_poll_for_qrcode();
  void set_allocated_poll_for_qrcode(::qrcode::poll::PollForQrCode* poll_for_qrcode);
  private:
  const ::qrcode::poll::PollForQrCode& _internal_poll_for_qrcode() const;
  ::qrcode::poll::PollForQrCode* _internal_mutable_poll_for_qrcode();
  public:

  // optional .complex.poll.UserInterface on_start_ui_action = 5;
  bool has_on_start_ui_action() const;
  private:
  bool _internal_has_on_start_ui_action() const;
  public:
  void clear_on_start_ui_action();
  const ::complex::poll::UserInterface& on_start_ui_action() const;
  ::complex::poll::UserInterface* release_on_start_ui_action();
  ::complex::poll::UserInterface* mutable_on_start_ui_action();
  void set_allocated_on_start_ui_action(::complex::poll::UserInterface* on_start_ui_action);
  private:
  const ::complex::poll::UserInterface& _internal_on_start_ui_action() const;
  ::complex::poll::UserInterface* _internal_mutable_on_start_ui_action();
  public:

  // optional .complex.poll.UserInterface on_event_ui_action = 6;
  bool has_on_event_ui_action() const;
  private:
  bool _internal_has_on_event_ui_action() const;
  public:
  void clear_on_event_ui_action();
  const ::complex::poll::UserInterface& on_event_ui_action() const;
  ::complex::poll::UserInterface* release_on_event_ui_action();
  ::complex::poll::UserInterface* mutable_on_event_ui_action();
  void set_allocated_on_event_ui_action(::complex::poll::UserInterface* on_event_ui_action);
  private:
  const ::complex::poll::UserInterface& _internal_on_event_ui_action() const;
  ::complex::poll::UserInterface* _internal_mutable_on_event_ui_action();
  public:

  // optional .complex.poll.MifareCardAction on_mifare_card_present = 7;
  bool has_on_mifare_card_present() const;
  private:
  bool _internal_has_on_mifare_card_present() const;
  public:
  void clear_on_mifare_card_present();
  const ::complex::poll::MifareCardAction& on_mifare_card_present() const;
  ::complex::poll::MifareCardAction* release_on_mifare_card_present();
  ::complex::poll::MifareCardAction* mutable_on_mifare_card_present();
  void set_allocated_on_mifare_card_present(::complex::poll::MifareCardAction* on_mifare_card_present);
  private:
  const ::complex::poll::MifareCardAction& _internal_on_mifare_card_present() const;
  ::complex::poll::MifareCardAction* _internal_mutable_on_mifare_card_present();
  public:

  // optional .contactless.poll.PollForToken poll_for_token = 1;
  bool has_poll_for_token() const;
  private:
  bool _internal_has_poll_for_token() const;
  public:
  void clear_poll_for_token();
  const ::contactless::poll::PollForToken& poll_for_token() const;
  ::contactless::poll::PollForToken* release_poll_for_token();
  ::contactless::poll::PollForToken* mutable_poll_for_token();
  void set_allocated_poll_for_token(::contactless::poll::PollForToken* poll_for_token);
  private:
  const ::contactless::poll::PollForToken& _internal_poll_for_token() const;
  ::contactless::poll::PollForToken* _internal_mutable_poll_for_token();
  public:

  // optional .contactless.transaction.PerformTransaction perform_txn = 2;
  bool has_perform_txn() const;
  private:
  bool _internal_has_perform_txn() const;
  public:
  void clear_perform_txn();
  const ::contactless::transaction::PerformTransaction& perform_txn() const;
  ::contactless::transaction::PerformTransaction* release_perform_txn();
  ::contactless::transaction::PerformTransaction* mutable_perform_txn();
  void set_allocated_perform_txn(::contactless::transaction::PerformTransaction* perform_txn);
  private:
  const ::contactless::transaction::PerformTransaction& _internal_perform_txn() const;
  ::contactless::transaction::PerformTransaction* _internal_mutable_perform_txn();
  public:

  void clear_contactless();
  ContactlessCase contactless_case() const;
  // @@protoc_insertion_point(class_scope:complex.poll.PollForEvent)
 private:
  class _Internal;
  void set_has_poll_for_token();
  void set_has_perform_txn();

  inline bool has_contactless() const;
  inline void clear_has_contactless();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::touchscreen::poll::PollTouchscreen* poll_touchscreen_;
  ::qrcode::poll::PollForQrCode* poll_for_qrcode_;
  ::complex::poll::UserInterface* on_start_ui_action_;
  ::complex::poll::UserInterface* on_event_ui_action_;
  ::complex::poll::MifareCardAction* on_mifare_card_present_;
  union ContactlessUnion {
    ContactlessUnion() {}
    ::contactless::poll::PollForToken* poll_for_token_;
    ::contactless::transaction::PerformTransaction* perform_txn_;
  } contactless_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_complex_2fpoll_5ffor_5fevent_2eproto;
};
// -------------------------------------------------------------------

class UserInterface :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:complex.poll.UserInterface) */ {
 public:
  UserInterface();
  virtual ~UserInterface();

  UserInterface(const UserInterface& from);
  UserInterface(UserInterface&& from) noexcept
    : UserInterface() {
    *this = ::std::move(from);
  }

  inline UserInterface& operator=(const UserInterface& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInterface& operator=(UserInterface&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserInterface& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserInterface* internal_default_instance() {
    return reinterpret_cast<const UserInterface*>(
               &_UserInterface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserInterface& a, UserInterface& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInterface* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserInterface* New() const final {
    return CreateMaybeMessage<UserInterface>(nullptr);
  }

  UserInterface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserInterface>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserInterface& from);
  void MergeFrom(const UserInterface& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInterface* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "complex.poll.UserInterface";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_complex_2fpoll_5ffor_5fevent_2eproto);
    return ::descriptor_table_complex_2fpoll_5ffor_5fevent_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetLedsStateFieldNumber = 1,
    kShowScreenFieldNumber = 2,
  };
  // optional .misc.leds.Leds set_leds_state = 1;
  bool has_set_leds_state() const;
  private:
  bool _internal_has_set_leds_state() const;
  public:
  void clear_set_leds_state();
  const ::misc::leds::Leds& set_leds_state() const;
  ::misc::leds::Leds* release_set_leds_state();
  ::misc::leds::Leds* mutable_set_leds_state();
  void set_allocated_set_leds_state(::misc::leds::Leds* set_leds_state);
  private:
  const ::misc::leds::Leds& _internal_set_leds_state() const;
  ::misc::leds::Leds* _internal_mutable_set_leds_state();
  public:

  // optional .gui.screen.ShowScreen show_screen = 2;
  bool has_show_screen() const;
  private:
  bool _internal_has_show_screen() const;
  public:
  void clear_show_screen();
  const ::gui::screen::ShowScreen& show_screen() const;
  ::gui::screen::ShowScreen* release_show_screen();
  ::gui::screen::ShowScreen* mutable_show_screen();
  void set_allocated_show_screen(::gui::screen::ShowScreen* show_screen);
  private:
  const ::gui::screen::ShowScreen& _internal_show_screen() const;
  ::gui::screen::ShowScreen* _internal_mutable_show_screen();
  public:

  // @@protoc_insertion_point(class_scope:complex.poll.UserInterface)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::misc::leds::Leds* set_leds_state_;
  ::gui::screen::ShowScreen* show_screen_;
  friend struct ::TableStruct_complex_2fpoll_5ffor_5fevent_2eproto;
};
// -------------------------------------------------------------------

class MifareCardAction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:complex.poll.MifareCardAction) */ {
 public:
  MifareCardAction();
  virtual ~MifareCardAction();

  MifareCardAction(const MifareCardAction& from);
  MifareCardAction(MifareCardAction&& from) noexcept
    : MifareCardAction() {
    *this = ::std::move(from);
  }

  inline MifareCardAction& operator=(const MifareCardAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline MifareCardAction& operator=(MifareCardAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MifareCardAction& default_instance();

  enum ActionCase {
    kTroikaAv3ReadTicket = 1,
    ACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MifareCardAction* internal_default_instance() {
    return reinterpret_cast<const MifareCardAction*>(
               &_MifareCardAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MifareCardAction& a, MifareCardAction& b) {
    a.Swap(&b);
  }
  inline void Swap(MifareCardAction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MifareCardAction* New() const final {
    return CreateMaybeMessage<MifareCardAction>(nullptr);
  }

  MifareCardAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MifareCardAction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MifareCardAction& from);
  void MergeFrom(const MifareCardAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MifareCardAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "complex.poll.MifareCardAction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_complex_2fpoll_5ffor_5fevent_2eproto);
    return ::descriptor_table_complex_2fpoll_5ffor_5fevent_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTroikaAv3ReadTicketFieldNumber = 1,
  };
  // optional .troika.av3.read_ticket.ReadTicket troika_av3_read_ticket = 1;
  bool has_troika_av3_read_ticket() const;
  private:
  bool _internal_has_troika_av3_read_ticket() const;
  public:
  void clear_troika_av3_read_ticket();
  const ::troika::av3::read_ticket::ReadTicket& troika_av3_read_ticket() const;
  ::troika::av3::read_ticket::ReadTicket* release_troika_av3_read_ticket();
  ::troika::av3::read_ticket::ReadTicket* mutable_troika_av3_read_ticket();
  void set_allocated_troika_av3_read_ticket(::troika::av3::read_ticket::ReadTicket* troika_av3_read_ticket);
  private:
  const ::troika::av3::read_ticket::ReadTicket& _internal_troika_av3_read_ticket() const;
  ::troika::av3::read_ticket::ReadTicket* _internal_mutable_troika_av3_read_ticket();
  public:

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:complex.poll.MifareCardAction)
 private:
  class _Internal;
  void set_has_troika_av3_read_ticket();

  inline bool has_action() const;
  inline void clear_has_action();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  union ActionUnion {
    ActionUnion() {}
    ::troika::av3::read_ticket::ReadTicket* troika_av3_read_ticket_;
  } action_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_complex_2fpoll_5ffor_5fevent_2eproto;
};
// -------------------------------------------------------------------

class Event :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:complex.poll.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Event& default_instance();

  enum EventCase {
    kContactlessToken = 1,
    kContactlessTxnResult = 2,
    kTouchscreenEvent = 3,
    kQrcode = 4,
    kTroikaTicket = 5,
    EVENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(nullptr);
  }

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "complex.poll.Event";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_complex_2fpoll_5ffor_5fevent_2eproto);
    return ::descriptor_table_complex_2fpoll_5ffor_5fevent_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContactlessTokenFieldNumber = 1,
    kContactlessTxnResultFieldNumber = 2,
    kTouchscreenEventFieldNumber = 3,
    kQrcodeFieldNumber = 4,
    kTroikaTicketFieldNumber = 5,
  };
  // optional .contactless.token.Token contactless_token = 1;
  bool has_contactless_token() const;
  private:
  bool _internal_has_contactless_token() const;
  public:
  void clear_contactless_token();
  const ::contactless::token::Token& contactless_token() const;
  ::contactless::token::Token* release_contactless_token();
  ::contactless::token::Token* mutable_contactless_token();
  void set_allocated_contactless_token(::contactless::token::Token* contactless_token);
  private:
  const ::contactless::token::Token& _internal_contactless_token() const;
  ::contactless::token::Token* _internal_mutable_contactless_token();
  public:

  // optional .contactless.transaction.TransactionResult contactless_txn_result = 2;
  bool has_contactless_txn_result() const;
  private:
  bool _internal_has_contactless_txn_result() const;
  public:
  void clear_contactless_txn_result();
  const ::contactless::transaction::TransactionResult& contactless_txn_result() const;
  ::contactless::transaction::TransactionResult* release_contactless_txn_result();
  ::contactless::transaction::TransactionResult* mutable_contactless_txn_result();
  void set_allocated_contactless_txn_result(::contactless::transaction::TransactionResult* contactless_txn_result);
  private:
  const ::contactless::transaction::TransactionResult& _internal_contactless_txn_result() const;
  ::contactless::transaction::TransactionResult* _internal_mutable_contactless_txn_result();
  public:

  // optional .touchscreen.event.TouchscreenEvent touchscreen_event = 3;
  bool has_touchscreen_event() const;
  private:
  bool _internal_has_touchscreen_event() const;
  public:
  void clear_touchscreen_event();
  const ::touchscreen::event::TouchscreenEvent& touchscreen_event() const;
  ::touchscreen::event::TouchscreenEvent* release_touchscreen_event();
  ::touchscreen::event::TouchscreenEvent* mutable_touchscreen_event();
  void set_allocated_touchscreen_event(::touchscreen::event::TouchscreenEvent* touchscreen_event);
  private:
  const ::touchscreen::event::TouchscreenEvent& _internal_touchscreen_event() const;
  ::touchscreen::event::TouchscreenEvent* _internal_mutable_touchscreen_event();
  public:

  // optional .qrcode.event.QrCodeEvent qrcode = 4;
  bool has_qrcode() const;
  private:
  bool _internal_has_qrcode() const;
  public:
  void clear_qrcode();
  const ::qrcode::event::QrCodeEvent& qrcode() const;
  ::qrcode::event::QrCodeEvent* release_qrcode();
  ::qrcode::event::QrCodeEvent* mutable_qrcode();
  void set_allocated_qrcode(::qrcode::event::QrCodeEvent* qrcode);
  private:
  const ::qrcode::event::QrCodeEvent& _internal_qrcode() const;
  ::qrcode::event::QrCodeEvent* _internal_mutable_qrcode();
  public:

  // optional .troika.av3.read_ticket.Ticket troika_ticket = 5;
  bool has_troika_ticket() const;
  private:
  bool _internal_has_troika_ticket() const;
  public:
  void clear_troika_ticket();
  const ::troika::av3::read_ticket::Ticket& troika_ticket() const;
  ::troika::av3::read_ticket::Ticket* release_troika_ticket();
  ::troika::av3::read_ticket::Ticket* mutable_troika_ticket();
  void set_allocated_troika_ticket(::troika::av3::read_ticket::Ticket* troika_ticket);
  private:
  const ::troika::av3::read_ticket::Ticket& _internal_troika_ticket() const;
  ::troika::av3::read_ticket::Ticket* _internal_mutable_troika_ticket();
  public:

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:complex.poll.Event)
 private:
  class _Internal;
  void set_has_contactless_token();
  void set_has_contactless_txn_result();
  void set_has_touchscreen_event();
  void set_has_qrcode();
  void set_has_troika_ticket();

  inline bool has_event() const;
  inline void clear_has_event();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  union EventUnion {
    EventUnion() {}
    ::contactless::token::Token* contactless_token_;
    ::contactless::transaction::TransactionResult* contactless_txn_result_;
    ::touchscreen::event::TouchscreenEvent* touchscreen_event_;
    ::qrcode::event::QrCodeEvent* qrcode_;
    ::troika::av3::read_ticket::Ticket* troika_ticket_;
  } event_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_complex_2fpoll_5ffor_5fevent_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PollForEvent

// optional .contactless.poll.PollForToken poll_for_token = 1;
inline bool PollForEvent::_internal_has_poll_for_token() const {
  return contactless_case() == kPollForToken;
}
inline bool PollForEvent::has_poll_for_token() const {
  return _internal_has_poll_for_token();
}
inline void PollForEvent::set_has_poll_for_token() {
  _oneof_case_[0] = kPollForToken;
}
inline ::contactless::poll::PollForToken* PollForEvent::release_poll_for_token() {
  // @@protoc_insertion_point(field_release:complex.poll.PollForEvent.poll_for_token)
  if (_internal_has_poll_for_token()) {
    clear_has_contactless();
      ::contactless::poll::PollForToken* temp = contactless_.poll_for_token_;
    contactless_.poll_for_token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::contactless::poll::PollForToken& PollForEvent::_internal_poll_for_token() const {
  return _internal_has_poll_for_token()
      ? *contactless_.poll_for_token_
      : *reinterpret_cast< ::contactless::poll::PollForToken*>(&::contactless::poll::_PollForToken_default_instance_);
}
inline const ::contactless::poll::PollForToken& PollForEvent::poll_for_token() const {
  // @@protoc_insertion_point(field_get:complex.poll.PollForEvent.poll_for_token)
  return _internal_poll_for_token();
}
inline ::contactless::poll::PollForToken* PollForEvent::_internal_mutable_poll_for_token() {
  if (!_internal_has_poll_for_token()) {
    clear_contactless();
    set_has_poll_for_token();
    contactless_.poll_for_token_ = CreateMaybeMessage< ::contactless::poll::PollForToken >(
        GetArenaNoVirtual());
  }
  return contactless_.poll_for_token_;
}
inline ::contactless::poll::PollForToken* PollForEvent::mutable_poll_for_token() {
  // @@protoc_insertion_point(field_mutable:complex.poll.PollForEvent.poll_for_token)
  return _internal_mutable_poll_for_token();
}

// optional .contactless.transaction.PerformTransaction perform_txn = 2;
inline bool PollForEvent::_internal_has_perform_txn() const {
  return contactless_case() == kPerformTxn;
}
inline bool PollForEvent::has_perform_txn() const {
  return _internal_has_perform_txn();
}
inline void PollForEvent::set_has_perform_txn() {
  _oneof_case_[0] = kPerformTxn;
}
inline ::contactless::transaction::PerformTransaction* PollForEvent::release_perform_txn() {
  // @@protoc_insertion_point(field_release:complex.poll.PollForEvent.perform_txn)
  if (_internal_has_perform_txn()) {
    clear_has_contactless();
      ::contactless::transaction::PerformTransaction* temp = contactless_.perform_txn_;
    contactless_.perform_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::contactless::transaction::PerformTransaction& PollForEvent::_internal_perform_txn() const {
  return _internal_has_perform_txn()
      ? *contactless_.perform_txn_
      : *reinterpret_cast< ::contactless::transaction::PerformTransaction*>(&::contactless::transaction::_PerformTransaction_default_instance_);
}
inline const ::contactless::transaction::PerformTransaction& PollForEvent::perform_txn() const {
  // @@protoc_insertion_point(field_get:complex.poll.PollForEvent.perform_txn)
  return _internal_perform_txn();
}
inline ::contactless::transaction::PerformTransaction* PollForEvent::_internal_mutable_perform_txn() {
  if (!_internal_has_perform_txn()) {
    clear_contactless();
    set_has_perform_txn();
    contactless_.perform_txn_ = CreateMaybeMessage< ::contactless::transaction::PerformTransaction >(
        GetArenaNoVirtual());
  }
  return contactless_.perform_txn_;
}
inline ::contactless::transaction::PerformTransaction* PollForEvent::mutable_perform_txn() {
  // @@protoc_insertion_point(field_mutable:complex.poll.PollForEvent.perform_txn)
  return _internal_mutable_perform_txn();
}

// optional .touchscreen.poll.PollTouchscreen poll_touchscreen = 3;
inline bool PollForEvent::_internal_has_poll_touchscreen() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || poll_touchscreen_ != nullptr);
  return value;
}
inline bool PollForEvent::has_poll_touchscreen() const {
  return _internal_has_poll_touchscreen();
}
inline const ::touchscreen::poll::PollTouchscreen& PollForEvent::_internal_poll_touchscreen() const {
  const ::touchscreen::poll::PollTouchscreen* p = poll_touchscreen_;
  return p != nullptr ? *p : *reinterpret_cast<const ::touchscreen::poll::PollTouchscreen*>(
      &::touchscreen::poll::_PollTouchscreen_default_instance_);
}
inline const ::touchscreen::poll::PollTouchscreen& PollForEvent::poll_touchscreen() const {
  // @@protoc_insertion_point(field_get:complex.poll.PollForEvent.poll_touchscreen)
  return _internal_poll_touchscreen();
}
inline ::touchscreen::poll::PollTouchscreen* PollForEvent::release_poll_touchscreen() {
  // @@protoc_insertion_point(field_release:complex.poll.PollForEvent.poll_touchscreen)
  _has_bits_[0] &= ~0x00000001u;
  ::touchscreen::poll::PollTouchscreen* temp = poll_touchscreen_;
  poll_touchscreen_ = nullptr;
  return temp;
}
inline ::touchscreen::poll::PollTouchscreen* PollForEvent::_internal_mutable_poll_touchscreen() {
  _has_bits_[0] |= 0x00000001u;
  if (poll_touchscreen_ == nullptr) {
    auto* p = CreateMaybeMessage<::touchscreen::poll::PollTouchscreen>(GetArenaNoVirtual());
    poll_touchscreen_ = p;
  }
  return poll_touchscreen_;
}
inline ::touchscreen::poll::PollTouchscreen* PollForEvent::mutable_poll_touchscreen() {
  // @@protoc_insertion_point(field_mutable:complex.poll.PollForEvent.poll_touchscreen)
  return _internal_mutable_poll_touchscreen();
}
inline void PollForEvent::set_allocated_poll_touchscreen(::touchscreen::poll::PollTouchscreen* poll_touchscreen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(poll_touchscreen_);
  }
  if (poll_touchscreen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      poll_touchscreen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, poll_touchscreen, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  poll_touchscreen_ = poll_touchscreen;
  // @@protoc_insertion_point(field_set_allocated:complex.poll.PollForEvent.poll_touchscreen)
}

// optional .qrcode.poll.PollForQrCode poll_for_qrcode = 4;
inline bool PollForEvent::_internal_has_poll_for_qrcode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || poll_for_qrcode_ != nullptr);
  return value;
}
inline bool PollForEvent::has_poll_for_qrcode() const {
  return _internal_has_poll_for_qrcode();
}
inline const ::qrcode::poll::PollForQrCode& PollForEvent::_internal_poll_for_qrcode() const {
  const ::qrcode::poll::PollForQrCode* p = poll_for_qrcode_;
  return p != nullptr ? *p : *reinterpret_cast<const ::qrcode::poll::PollForQrCode*>(
      &::qrcode::poll::_PollForQrCode_default_instance_);
}
inline const ::qrcode::poll::PollForQrCode& PollForEvent::poll_for_qrcode() const {
  // @@protoc_insertion_point(field_get:complex.poll.PollForEvent.poll_for_qrcode)
  return _internal_poll_for_qrcode();
}
inline ::qrcode::poll::PollForQrCode* PollForEvent::release_poll_for_qrcode() {
  // @@protoc_insertion_point(field_release:complex.poll.PollForEvent.poll_for_qrcode)
  _has_bits_[0] &= ~0x00000002u;
  ::qrcode::poll::PollForQrCode* temp = poll_for_qrcode_;
  poll_for_qrcode_ = nullptr;
  return temp;
}
inline ::qrcode::poll::PollForQrCode* PollForEvent::_internal_mutable_poll_for_qrcode() {
  _has_bits_[0] |= 0x00000002u;
  if (poll_for_qrcode_ == nullptr) {
    auto* p = CreateMaybeMessage<::qrcode::poll::PollForQrCode>(GetArenaNoVirtual());
    poll_for_qrcode_ = p;
  }
  return poll_for_qrcode_;
}
inline ::qrcode::poll::PollForQrCode* PollForEvent::mutable_poll_for_qrcode() {
  // @@protoc_insertion_point(field_mutable:complex.poll.PollForEvent.poll_for_qrcode)
  return _internal_mutable_poll_for_qrcode();
}
inline void PollForEvent::set_allocated_poll_for_qrcode(::qrcode::poll::PollForQrCode* poll_for_qrcode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(poll_for_qrcode_);
  }
  if (poll_for_qrcode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      poll_for_qrcode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, poll_for_qrcode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  poll_for_qrcode_ = poll_for_qrcode;
  // @@protoc_insertion_point(field_set_allocated:complex.poll.PollForEvent.poll_for_qrcode)
}

// optional .complex.poll.UserInterface on_start_ui_action = 5;
inline bool PollForEvent::_internal_has_on_start_ui_action() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || on_start_ui_action_ != nullptr);
  return value;
}
inline bool PollForEvent::has_on_start_ui_action() const {
  return _internal_has_on_start_ui_action();
}
inline void PollForEvent::clear_on_start_ui_action() {
  if (on_start_ui_action_ != nullptr) on_start_ui_action_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::complex::poll::UserInterface& PollForEvent::_internal_on_start_ui_action() const {
  const ::complex::poll::UserInterface* p = on_start_ui_action_;
  return p != nullptr ? *p : *reinterpret_cast<const ::complex::poll::UserInterface*>(
      &::complex::poll::_UserInterface_default_instance_);
}
inline const ::complex::poll::UserInterface& PollForEvent::on_start_ui_action() const {
  // @@protoc_insertion_point(field_get:complex.poll.PollForEvent.on_start_ui_action)
  return _internal_on_start_ui_action();
}
inline ::complex::poll::UserInterface* PollForEvent::release_on_start_ui_action() {
  // @@protoc_insertion_point(field_release:complex.poll.PollForEvent.on_start_ui_action)
  _has_bits_[0] &= ~0x00000004u;
  ::complex::poll::UserInterface* temp = on_start_ui_action_;
  on_start_ui_action_ = nullptr;
  return temp;
}
inline ::complex::poll::UserInterface* PollForEvent::_internal_mutable_on_start_ui_action() {
  _has_bits_[0] |= 0x00000004u;
  if (on_start_ui_action_ == nullptr) {
    auto* p = CreateMaybeMessage<::complex::poll::UserInterface>(GetArenaNoVirtual());
    on_start_ui_action_ = p;
  }
  return on_start_ui_action_;
}
inline ::complex::poll::UserInterface* PollForEvent::mutable_on_start_ui_action() {
  // @@protoc_insertion_point(field_mutable:complex.poll.PollForEvent.on_start_ui_action)
  return _internal_mutable_on_start_ui_action();
}
inline void PollForEvent::set_allocated_on_start_ui_action(::complex::poll::UserInterface* on_start_ui_action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete on_start_ui_action_;
  }
  if (on_start_ui_action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      on_start_ui_action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, on_start_ui_action, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  on_start_ui_action_ = on_start_ui_action;
  // @@protoc_insertion_point(field_set_allocated:complex.poll.PollForEvent.on_start_ui_action)
}

// optional .complex.poll.UserInterface on_event_ui_action = 6;
inline bool PollForEvent::_internal_has_on_event_ui_action() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || on_event_ui_action_ != nullptr);
  return value;
}
inline bool PollForEvent::has_on_event_ui_action() const {
  return _internal_has_on_event_ui_action();
}
inline void PollForEvent::clear_on_event_ui_action() {
  if (on_event_ui_action_ != nullptr) on_event_ui_action_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::complex::poll::UserInterface& PollForEvent::_internal_on_event_ui_action() const {
  const ::complex::poll::UserInterface* p = on_event_ui_action_;
  return p != nullptr ? *p : *reinterpret_cast<const ::complex::poll::UserInterface*>(
      &::complex::poll::_UserInterface_default_instance_);
}
inline const ::complex::poll::UserInterface& PollForEvent::on_event_ui_action() const {
  // @@protoc_insertion_point(field_get:complex.poll.PollForEvent.on_event_ui_action)
  return _internal_on_event_ui_action();
}
inline ::complex::poll::UserInterface* PollForEvent::release_on_event_ui_action() {
  // @@protoc_insertion_point(field_release:complex.poll.PollForEvent.on_event_ui_action)
  _has_bits_[0] &= ~0x00000008u;
  ::complex::poll::UserInterface* temp = on_event_ui_action_;
  on_event_ui_action_ = nullptr;
  return temp;
}
inline ::complex::poll::UserInterface* PollForEvent::_internal_mutable_on_event_ui_action() {
  _has_bits_[0] |= 0x00000008u;
  if (on_event_ui_action_ == nullptr) {
    auto* p = CreateMaybeMessage<::complex::poll::UserInterface>(GetArenaNoVirtual());
    on_event_ui_action_ = p;
  }
  return on_event_ui_action_;
}
inline ::complex::poll::UserInterface* PollForEvent::mutable_on_event_ui_action() {
  // @@protoc_insertion_point(field_mutable:complex.poll.PollForEvent.on_event_ui_action)
  return _internal_mutable_on_event_ui_action();
}
inline void PollForEvent::set_allocated_on_event_ui_action(::complex::poll::UserInterface* on_event_ui_action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete on_event_ui_action_;
  }
  if (on_event_ui_action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      on_event_ui_action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, on_event_ui_action, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  on_event_ui_action_ = on_event_ui_action;
  // @@protoc_insertion_point(field_set_allocated:complex.poll.PollForEvent.on_event_ui_action)
}

// optional .complex.poll.MifareCardAction on_mifare_card_present = 7;
inline bool PollForEvent::_internal_has_on_mifare_card_present() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || on_mifare_card_present_ != nullptr);
  return value;
}
inline bool PollForEvent::has_on_mifare_card_present() const {
  return _internal_has_on_mifare_card_present();
}
inline void PollForEvent::clear_on_mifare_card_present() {
  if (on_mifare_card_present_ != nullptr) on_mifare_card_present_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::complex::poll::MifareCardAction& PollForEvent::_internal_on_mifare_card_present() const {
  const ::complex::poll::MifareCardAction* p = on_mifare_card_present_;
  return p != nullptr ? *p : *reinterpret_cast<const ::complex::poll::MifareCardAction*>(
      &::complex::poll::_MifareCardAction_default_instance_);
}
inline const ::complex::poll::MifareCardAction& PollForEvent::on_mifare_card_present() const {
  // @@protoc_insertion_point(field_get:complex.poll.PollForEvent.on_mifare_card_present)
  return _internal_on_mifare_card_present();
}
inline ::complex::poll::MifareCardAction* PollForEvent::release_on_mifare_card_present() {
  // @@protoc_insertion_point(field_release:complex.poll.PollForEvent.on_mifare_card_present)
  _has_bits_[0] &= ~0x00000010u;
  ::complex::poll::MifareCardAction* temp = on_mifare_card_present_;
  on_mifare_card_present_ = nullptr;
  return temp;
}
inline ::complex::poll::MifareCardAction* PollForEvent::_internal_mutable_on_mifare_card_present() {
  _has_bits_[0] |= 0x00000010u;
  if (on_mifare_card_present_ == nullptr) {
    auto* p = CreateMaybeMessage<::complex::poll::MifareCardAction>(GetArenaNoVirtual());
    on_mifare_card_present_ = p;
  }
  return on_mifare_card_present_;
}
inline ::complex::poll::MifareCardAction* PollForEvent::mutable_on_mifare_card_present() {
  // @@protoc_insertion_point(field_mutable:complex.poll.PollForEvent.on_mifare_card_present)
  return _internal_mutable_on_mifare_card_present();
}
inline void PollForEvent::set_allocated_on_mifare_card_present(::complex::poll::MifareCardAction* on_mifare_card_present) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete on_mifare_card_present_;
  }
  if (on_mifare_card_present) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      on_mifare_card_present = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, on_mifare_card_present, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  on_mifare_card_present_ = on_mifare_card_present;
  // @@protoc_insertion_point(field_set_allocated:complex.poll.PollForEvent.on_mifare_card_present)
}

inline bool PollForEvent::has_contactless() const {
  return contactless_case() != CONTACTLESS_NOT_SET;
}
inline void PollForEvent::clear_has_contactless() {
  _oneof_case_[0] = CONTACTLESS_NOT_SET;
}
inline PollForEvent::ContactlessCase PollForEvent::contactless_case() const {
  return PollForEvent::ContactlessCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UserInterface

// optional .misc.leds.Leds set_leds_state = 1;
inline bool UserInterface::_internal_has_set_leds_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || set_leds_state_ != nullptr);
  return value;
}
inline bool UserInterface::has_set_leds_state() const {
  return _internal_has_set_leds_state();
}
inline const ::misc::leds::Leds& UserInterface::_internal_set_leds_state() const {
  const ::misc::leds::Leds* p = set_leds_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::misc::leds::Leds*>(
      &::misc::leds::_Leds_default_instance_);
}
inline const ::misc::leds::Leds& UserInterface::set_leds_state() const {
  // @@protoc_insertion_point(field_get:complex.poll.UserInterface.set_leds_state)
  return _internal_set_leds_state();
}
inline ::misc::leds::Leds* UserInterface::release_set_leds_state() {
  // @@protoc_insertion_point(field_release:complex.poll.UserInterface.set_leds_state)
  _has_bits_[0] &= ~0x00000001u;
  ::misc::leds::Leds* temp = set_leds_state_;
  set_leds_state_ = nullptr;
  return temp;
}
inline ::misc::leds::Leds* UserInterface::_internal_mutable_set_leds_state() {
  _has_bits_[0] |= 0x00000001u;
  if (set_leds_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::misc::leds::Leds>(GetArenaNoVirtual());
    set_leds_state_ = p;
  }
  return set_leds_state_;
}
inline ::misc::leds::Leds* UserInterface::mutable_set_leds_state() {
  // @@protoc_insertion_point(field_mutable:complex.poll.UserInterface.set_leds_state)
  return _internal_mutable_set_leds_state();
}
inline void UserInterface::set_allocated_set_leds_state(::misc::leds::Leds* set_leds_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(set_leds_state_);
  }
  if (set_leds_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      set_leds_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_leds_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  set_leds_state_ = set_leds_state;
  // @@protoc_insertion_point(field_set_allocated:complex.poll.UserInterface.set_leds_state)
}

// optional .gui.screen.ShowScreen show_screen = 2;
inline bool UserInterface::_internal_has_show_screen() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || show_screen_ != nullptr);
  return value;
}
inline bool UserInterface::has_show_screen() const {
  return _internal_has_show_screen();
}
inline const ::gui::screen::ShowScreen& UserInterface::_internal_show_screen() const {
  const ::gui::screen::ShowScreen* p = show_screen_;
  return p != nullptr ? *p : *reinterpret_cast<const ::gui::screen::ShowScreen*>(
      &::gui::screen::_ShowScreen_default_instance_);
}
inline const ::gui::screen::ShowScreen& UserInterface::show_screen() const {
  // @@protoc_insertion_point(field_get:complex.poll.UserInterface.show_screen)
  return _internal_show_screen();
}
inline ::gui::screen::ShowScreen* UserInterface::release_show_screen() {
  // @@protoc_insertion_point(field_release:complex.poll.UserInterface.show_screen)
  _has_bits_[0] &= ~0x00000002u;
  ::gui::screen::ShowScreen* temp = show_screen_;
  show_screen_ = nullptr;
  return temp;
}
inline ::gui::screen::ShowScreen* UserInterface::_internal_mutable_show_screen() {
  _has_bits_[0] |= 0x00000002u;
  if (show_screen_ == nullptr) {
    auto* p = CreateMaybeMessage<::gui::screen::ShowScreen>(GetArenaNoVirtual());
    show_screen_ = p;
  }
  return show_screen_;
}
inline ::gui::screen::ShowScreen* UserInterface::mutable_show_screen() {
  // @@protoc_insertion_point(field_mutable:complex.poll.UserInterface.show_screen)
  return _internal_mutable_show_screen();
}
inline void UserInterface::set_allocated_show_screen(::gui::screen::ShowScreen* show_screen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(show_screen_);
  }
  if (show_screen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      show_screen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, show_screen, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  show_screen_ = show_screen;
  // @@protoc_insertion_point(field_set_allocated:complex.poll.UserInterface.show_screen)
}

// -------------------------------------------------------------------

// MifareCardAction

// optional .troika.av3.read_ticket.ReadTicket troika_av3_read_ticket = 1;
inline bool MifareCardAction::_internal_has_troika_av3_read_ticket() const {
  return action_case() == kTroikaAv3ReadTicket;
}
inline bool MifareCardAction::has_troika_av3_read_ticket() const {
  return _internal_has_troika_av3_read_ticket();
}
inline void MifareCardAction::set_has_troika_av3_read_ticket() {
  _oneof_case_[0] = kTroikaAv3ReadTicket;
}
inline ::troika::av3::read_ticket::ReadTicket* MifareCardAction::release_troika_av3_read_ticket() {
  // @@protoc_insertion_point(field_release:complex.poll.MifareCardAction.troika_av3_read_ticket)
  if (_internal_has_troika_av3_read_ticket()) {
    clear_has_action();
      ::troika::av3::read_ticket::ReadTicket* temp = action_.troika_av3_read_ticket_;
    action_.troika_av3_read_ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::troika::av3::read_ticket::ReadTicket& MifareCardAction::_internal_troika_av3_read_ticket() const {
  return _internal_has_troika_av3_read_ticket()
      ? *action_.troika_av3_read_ticket_
      : *reinterpret_cast< ::troika::av3::read_ticket::ReadTicket*>(&::troika::av3::read_ticket::_ReadTicket_default_instance_);
}
inline const ::troika::av3::read_ticket::ReadTicket& MifareCardAction::troika_av3_read_ticket() const {
  // @@protoc_insertion_point(field_get:complex.poll.MifareCardAction.troika_av3_read_ticket)
  return _internal_troika_av3_read_ticket();
}
inline ::troika::av3::read_ticket::ReadTicket* MifareCardAction::_internal_mutable_troika_av3_read_ticket() {
  if (!_internal_has_troika_av3_read_ticket()) {
    clear_action();
    set_has_troika_av3_read_ticket();
    action_.troika_av3_read_ticket_ = CreateMaybeMessage< ::troika::av3::read_ticket::ReadTicket >(
        GetArenaNoVirtual());
  }
  return action_.troika_av3_read_ticket_;
}
inline ::troika::av3::read_ticket::ReadTicket* MifareCardAction::mutable_troika_av3_read_ticket() {
  // @@protoc_insertion_point(field_mutable:complex.poll.MifareCardAction.troika_av3_read_ticket)
  return _internal_mutable_troika_av3_read_ticket();
}

inline bool MifareCardAction::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void MifareCardAction::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline MifareCardAction::ActionCase MifareCardAction::action_case() const {
  return MifareCardAction::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event

// optional .contactless.token.Token contactless_token = 1;
inline bool Event::_internal_has_contactless_token() const {
  return event_case() == kContactlessToken;
}
inline bool Event::has_contactless_token() const {
  return _internal_has_contactless_token();
}
inline void Event::set_has_contactless_token() {
  _oneof_case_[0] = kContactlessToken;
}
inline ::contactless::token::Token* Event::release_contactless_token() {
  // @@protoc_insertion_point(field_release:complex.poll.Event.contactless_token)
  if (_internal_has_contactless_token()) {
    clear_has_event();
      ::contactless::token::Token* temp = event_.contactless_token_;
    event_.contactless_token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::contactless::token::Token& Event::_internal_contactless_token() const {
  return _internal_has_contactless_token()
      ? *event_.contactless_token_
      : *reinterpret_cast< ::contactless::token::Token*>(&::contactless::token::_Token_default_instance_);
}
inline const ::contactless::token::Token& Event::contactless_token() const {
  // @@protoc_insertion_point(field_get:complex.poll.Event.contactless_token)
  return _internal_contactless_token();
}
inline ::contactless::token::Token* Event::_internal_mutable_contactless_token() {
  if (!_internal_has_contactless_token()) {
    clear_event();
    set_has_contactless_token();
    event_.contactless_token_ = CreateMaybeMessage< ::contactless::token::Token >(
        GetArenaNoVirtual());
  }
  return event_.contactless_token_;
}
inline ::contactless::token::Token* Event::mutable_contactless_token() {
  // @@protoc_insertion_point(field_mutable:complex.poll.Event.contactless_token)
  return _internal_mutable_contactless_token();
}

// optional .contactless.transaction.TransactionResult contactless_txn_result = 2;
inline bool Event::_internal_has_contactless_txn_result() const {
  return event_case() == kContactlessTxnResult;
}
inline bool Event::has_contactless_txn_result() const {
  return _internal_has_contactless_txn_result();
}
inline void Event::set_has_contactless_txn_result() {
  _oneof_case_[0] = kContactlessTxnResult;
}
inline ::contactless::transaction::TransactionResult* Event::release_contactless_txn_result() {
  // @@protoc_insertion_point(field_release:complex.poll.Event.contactless_txn_result)
  if (_internal_has_contactless_txn_result()) {
    clear_has_event();
      ::contactless::transaction::TransactionResult* temp = event_.contactless_txn_result_;
    event_.contactless_txn_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::contactless::transaction::TransactionResult& Event::_internal_contactless_txn_result() const {
  return _internal_has_contactless_txn_result()
      ? *event_.contactless_txn_result_
      : *reinterpret_cast< ::contactless::transaction::TransactionResult*>(&::contactless::transaction::_TransactionResult_default_instance_);
}
inline const ::contactless::transaction::TransactionResult& Event::contactless_txn_result() const {
  // @@protoc_insertion_point(field_get:complex.poll.Event.contactless_txn_result)
  return _internal_contactless_txn_result();
}
inline ::contactless::transaction::TransactionResult* Event::_internal_mutable_contactless_txn_result() {
  if (!_internal_has_contactless_txn_result()) {
    clear_event();
    set_has_contactless_txn_result();
    event_.contactless_txn_result_ = CreateMaybeMessage< ::contactless::transaction::TransactionResult >(
        GetArenaNoVirtual());
  }
  return event_.contactless_txn_result_;
}
inline ::contactless::transaction::TransactionResult* Event::mutable_contactless_txn_result() {
  // @@protoc_insertion_point(field_mutable:complex.poll.Event.contactless_txn_result)
  return _internal_mutable_contactless_txn_result();
}

// optional .touchscreen.event.TouchscreenEvent touchscreen_event = 3;
inline bool Event::_internal_has_touchscreen_event() const {
  return event_case() == kTouchscreenEvent;
}
inline bool Event::has_touchscreen_event() const {
  return _internal_has_touchscreen_event();
}
inline void Event::set_has_touchscreen_event() {
  _oneof_case_[0] = kTouchscreenEvent;
}
inline ::touchscreen::event::TouchscreenEvent* Event::release_touchscreen_event() {
  // @@protoc_insertion_point(field_release:complex.poll.Event.touchscreen_event)
  if (_internal_has_touchscreen_event()) {
    clear_has_event();
      ::touchscreen::event::TouchscreenEvent* temp = event_.touchscreen_event_;
    event_.touchscreen_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::touchscreen::event::TouchscreenEvent& Event::_internal_touchscreen_event() const {
  return _internal_has_touchscreen_event()
      ? *event_.touchscreen_event_
      : *reinterpret_cast< ::touchscreen::event::TouchscreenEvent*>(&::touchscreen::event::_TouchscreenEvent_default_instance_);
}
inline const ::touchscreen::event::TouchscreenEvent& Event::touchscreen_event() const {
  // @@protoc_insertion_point(field_get:complex.poll.Event.touchscreen_event)
  return _internal_touchscreen_event();
}
inline ::touchscreen::event::TouchscreenEvent* Event::_internal_mutable_touchscreen_event() {
  if (!_internal_has_touchscreen_event()) {
    clear_event();
    set_has_touchscreen_event();
    event_.touchscreen_event_ = CreateMaybeMessage< ::touchscreen::event::TouchscreenEvent >(
        GetArenaNoVirtual());
  }
  return event_.touchscreen_event_;
}
inline ::touchscreen::event::TouchscreenEvent* Event::mutable_touchscreen_event() {
  // @@protoc_insertion_point(field_mutable:complex.poll.Event.touchscreen_event)
  return _internal_mutable_touchscreen_event();
}

// optional .qrcode.event.QrCodeEvent qrcode = 4;
inline bool Event::_internal_has_qrcode() const {
  return event_case() == kQrcode;
}
inline bool Event::has_qrcode() const {
  return _internal_has_qrcode();
}
inline void Event::set_has_qrcode() {
  _oneof_case_[0] = kQrcode;
}
inline ::qrcode::event::QrCodeEvent* Event::release_qrcode() {
  // @@protoc_insertion_point(field_release:complex.poll.Event.qrcode)
  if (_internal_has_qrcode()) {
    clear_has_event();
      ::qrcode::event::QrCodeEvent* temp = event_.qrcode_;
    event_.qrcode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qrcode::event::QrCodeEvent& Event::_internal_qrcode() const {
  return _internal_has_qrcode()
      ? *event_.qrcode_
      : *reinterpret_cast< ::qrcode::event::QrCodeEvent*>(&::qrcode::event::_QrCodeEvent_default_instance_);
}
inline const ::qrcode::event::QrCodeEvent& Event::qrcode() const {
  // @@protoc_insertion_point(field_get:complex.poll.Event.qrcode)
  return _internal_qrcode();
}
inline ::qrcode::event::QrCodeEvent* Event::_internal_mutable_qrcode() {
  if (!_internal_has_qrcode()) {
    clear_event();
    set_has_qrcode();
    event_.qrcode_ = CreateMaybeMessage< ::qrcode::event::QrCodeEvent >(
        GetArenaNoVirtual());
  }
  return event_.qrcode_;
}
inline ::qrcode::event::QrCodeEvent* Event::mutable_qrcode() {
  // @@protoc_insertion_point(field_mutable:complex.poll.Event.qrcode)
  return _internal_mutable_qrcode();
}

// optional .troika.av3.read_ticket.Ticket troika_ticket = 5;
inline bool Event::_internal_has_troika_ticket() const {
  return event_case() == kTroikaTicket;
}
inline bool Event::has_troika_ticket() const {
  return _internal_has_troika_ticket();
}
inline void Event::set_has_troika_ticket() {
  _oneof_case_[0] = kTroikaTicket;
}
inline ::troika::av3::read_ticket::Ticket* Event::release_troika_ticket() {
  // @@protoc_insertion_point(field_release:complex.poll.Event.troika_ticket)
  if (_internal_has_troika_ticket()) {
    clear_has_event();
      ::troika::av3::read_ticket::Ticket* temp = event_.troika_ticket_;
    event_.troika_ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::troika::av3::read_ticket::Ticket& Event::_internal_troika_ticket() const {
  return _internal_has_troika_ticket()
      ? *event_.troika_ticket_
      : *reinterpret_cast< ::troika::av3::read_ticket::Ticket*>(&::troika::av3::read_ticket::_Ticket_default_instance_);
}
inline const ::troika::av3::read_ticket::Ticket& Event::troika_ticket() const {
  // @@protoc_insertion_point(field_get:complex.poll.Event.troika_ticket)
  return _internal_troika_ticket();
}
inline ::troika::av3::read_ticket::Ticket* Event::_internal_mutable_troika_ticket() {
  if (!_internal_has_troika_ticket()) {
    clear_event();
    set_has_troika_ticket();
    event_.troika_ticket_ = CreateMaybeMessage< ::troika::av3::read_ticket::Ticket >(
        GetArenaNoVirtual());
  }
  return event_.troika_ticket_;
}
inline ::troika::av3::read_ticket::Ticket* Event::mutable_troika_ticket() {
  // @@protoc_insertion_point(field_mutable:complex.poll.Event.troika_ticket)
  return _internal_mutable_troika_ticket();
}

inline bool Event::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void Event::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline Event::EventCase Event::event_case() const {
  return Event::EventCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace poll
}  // namespace complex

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_complex_2fpoll_5ffor_5fevent_2eproto
